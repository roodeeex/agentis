"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject";
exports.ids = ["vendor-chunks/@ethersproject"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abi/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vX3ZlcnNpb24uanM/YmZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJpLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder),\n/* harmony export */   defaultAbiCoder: () => (/* binding */ defaultAbiCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/address */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/address.js\");\n/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/array */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/boolean */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\");\n/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/bytes */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/null.js\");\n/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/number.js\");\n/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/string */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/string.js\");\n/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/tuple */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./fragments */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\n\n\n\n\n\n\n\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nclass AbiCoder {\n    constructor(coerceFunc) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new _coders_address__WEBPACK_IMPORTED_MODULE_3__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean__WEBPACK_IMPORTED_MODULE_4__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string__WEBPACK_IMPORTED_MODULE_5__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes__WEBPACK_IMPORTED_MODULE_6__.BytesCoder(param.name);\n            case \"array\":\n                return new _coders_array__WEBPACK_IMPORTED_MODULE_7__.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new _coders_null__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new _coders_number__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = (new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__.arrayify)(data), loose));\n    }\n}\nconst defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDZ0Q7QUFDVztBQUNaO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDd0I7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUN4QztBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEseUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQVk7QUFDdkM7QUFDQSwyQkFBMkIseURBQVk7QUFDdkM7QUFDQSwyQkFBMkIsdURBQVc7QUFDdEM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1CQUFtQiwyREFBTTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFNO0FBQ3pCO0FBQ0E7QUFDQSwwREFBMEQsa0RBQVM7QUFDbkUsMEJBQTBCLHFEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlEQUFNO0FBQ3BFLHlCQUF5Qiw0Q0FBNEM7QUFDckUseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBLDBEQUEwRCxrREFBUztBQUNuRSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrREFBUztBQUNuRSwwQkFBMEIscURBQVU7QUFDcEMsNENBQTRDLCtEQUFRO0FBQ3BEO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vYWJpLWNvZGVyLmpzPzIxOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXJcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5XCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhblwiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbFwiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmdcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGVcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZXJjZUZ1bmMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMgfHwgbnVsbCk7XG4gICAgfVxuICAgIF9nZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwidHVwbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIoKHBhcmFtLmNvbXBvbmVudHMgfHwgW10pLm1hcCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb2Rlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0pLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAyNTYgfHwgKHNpemUgJSA4KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgX2dldFdvcmRTaXplKCkgeyByZXR1cm4gMzI7IH1cbiAgICBfZ2V0UmVhZGVyKGRhdGEsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoZGF0YSwgdGhpcy5fZ2V0V29yZFNpemUoKSwgdGhpcy5jb2VyY2VGdW5jLCBhbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgX2dldFdyaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIodGhpcy5fZ2V0V29yZFNpemUoKSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHR5cGVzOiB0eXBlcywgdmFsdWVzOiB2YWx1ZXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHRoaXMuX2dldFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKHRoaXMuX2dldFJlYWRlcihhcnJheWlmeShkYXRhKSwgbG9vc2UpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdEFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nclass Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nclass Writer {\n    constructor(wordSize) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nclass Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_coerceFunc\", coerceFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUMrRDtBQUN2QjtBQUNNO0FBQ1o7QUFDVDtBQUN0QyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBUztBQUN4QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQU07QUFDckM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0IsOERBQVE7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQiw0REFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBUSxDQUFDLCtEQUFTO0FBQ3RDO0FBQ0EscURBQXFELHlEQUFNO0FBQzNEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQiw0REFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEseUVBQWMsZ0JBQWdCLDhEQUFRO0FBQzlDLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYztBQUN0QixRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyw2REFBTztBQUMvQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFNO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVM7QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzPzgzMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICAvLyBAVE9ETzogZGVmaW5lUmVhZE9ubHkgdGhlc2VcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XG4gICAgICAgIHRoaXMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkU2l6ZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KHdvcmRTaXplKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLl9kYXRhTGVuZ3RoOyB9XG4gICAgX3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoY29uY2F0KHdyaXRlci5fZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSByaWdodCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBjb25zdCBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gY29uY2F0KFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMud29yZFNpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuICAgICAgICAgICAgYnl0ZXMgPSBjb25jYXQoW3RoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSksIGJ5dGVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvLyBCaWdOdW1iZXJpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgbGVmdCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IHRoaXMud29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbb2Zmc2V0XSA9IHRoaXMuX2dldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYywgYWxsb3dMb29zZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9kYXRhXCIsIGFycmF5aWZ5KGRhdGEpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxsb3dMb29zZVwiLCBhbGxvd0xvb3NlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuX2RhdGEpOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy5fb2Zmc2V0OyB9XG4gICAgLy8gVGhlIGRlZmF1bHQgQ29lcmNlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGNvZXJjZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBuYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0pIDw9IDQ4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb2VyY2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZUZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGVyLmNvZXJjZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9wZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMud29yZFNpemUpICogdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLl9vZmZzZXQgKyBsZW5ndGggPD0gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy53b3JkU2l6ZSwgdGhpcy5fY29lcmNlRnVuYywgdGhpcy5hbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy5fcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMucmVhZEJ5dGVzKHRoaXMud29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, value) {\n        try {\n            value = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value);\n        }\n        catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(reader.readValue().toHexString(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUN1QztBQUNGO0FBQ1Q7QUFDbEMsMkJBQTJCLGtEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFVLENBQUMsZ0VBQVU7QUFDcEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2FkZHJlc3MuanM/YjhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgaGV4WmVyb1BhZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGhleFplcm9QYWQocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/address.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n// Clones the functionality of an existing Coder, but without a localName\nclass AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUM0QjtBQUN6QztBQUNPLDZCQUE2QixrREFBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzP2RlZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG4vLyBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgdW5kZWZpbmVkLCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5vbnltb3VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\nfunction pack(writer, coders, values) {\n    let arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nfunction unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nclass ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Coder {\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDa0M7QUFDVDtBQUN0QyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNnQjtBQUNKO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHlEQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkZBQTZGLHlEQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQU07QUFDakMsNEJBQTRCLG1EQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixrREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseURBQU07QUFDcEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQyw0QkFBNEIsc0RBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hcnJheS5qcz8xZTY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IENvZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQW5vbnltb3VzQ29kZXIgfSBmcm9tIFwiLi9hbm9ueW1vdXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXF1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoY29kZXJzLmxlbmd0aCAhPT0gYXJyYXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICBjb25zdCB1bmlxdWVOYW1lcyA9IGNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgICAvLyBBZGQgYW55IG5hbWVkIHBhcmFtZXRlcnMgKGkuZS4gdHVwbGVzKVxuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHZhbHVlOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBpLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgdmFsdWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG59XG5leHBvcnQgY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMzIgPiByZWFkZXIuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHJlYWRlci5fZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgY29kZXJzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/array.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDNEI7QUFDbEMsMkJBQTJCLGtEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYm9vbGVhbi5qcz9iMDA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLnR5cGUsICFyZWFkZXIucmVhZFZhbHVlKCkuaXNaZXJvKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\nclass DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader)));\n    }\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDNEM7QUFDaEI7QUFDbEMsZ0NBQWdDLGtEQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ieXRlcy5qcz8xYmI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n// @TODO: Merge this with bytes\nclass FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, value) {\n        let data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size)));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUM0QztBQUNoQjtBQUN6QztBQUNPLDhCQUE4QixrREFBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9maXhlZC1ieXRlcy5qcz83YTkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIEBUT0RPOiBNZXJnZSB0aGlzIHdpdGggYnl0ZXNcbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDNEI7QUFDbEMsd0JBQXdCLGtEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzPzc0MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhbXSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBudWxsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/null.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, value) {\n        let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.One).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        }\n        else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n}\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ3dDO0FBQ3lCO0FBQ3JDO0FBQ2xDLDBCQUEwQixrREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBUztBQUN6QjtBQUNBLDJCQUEyQixnRUFBVTtBQUNyQztBQUNBO0FBQ0EsZ0RBQWdELHlEQUFHLE1BQU0saUVBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVtYmVyLmpzP2FiODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBNYXhVaW50MjU2LCBOZWdhdGl2ZU9uZSwgT25lLCBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4IC0gMSk7XG4gICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYubHQoWmVybykgfHwgdi5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdi50b1R3b3ModGhpcy5zaXplICogOCkubWFzayh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZnJvbVR3b3ModGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/number.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n\n\n\nclass StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, value) {\n        return super.encode(writer, (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n    }\n    decode(reader) {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDc0Q7QUFDdkI7QUFDckMsMEJBQTBCLHFEQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBVztBQUMvQztBQUNBO0FBQ0EsZUFBZSxvRUFBWTtBQUMzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvc3RyaW5nLmpzP2RhNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXNcIjtcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKHZhbHVlKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/string.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n\n\n\nclass TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, value) {\n        return (0,_array__WEBPACK_IMPORTED_MODULE_1__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_array__WEBPACK_IMPORTED_MODULE_1__.unpack)(reader, this.coders));\n    }\n}\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUM0QjtBQUNGO0FBQ2hDLHlCQUF5QixrREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFJO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQU07QUFDOUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL3R1cGxlLmpzPzU0YjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheVwiO1xuZXhwb3J0IGNsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXJzID0gY29kZXJzO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FormatTypes: () => (/* binding */ FormatTypes),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(object, key, params[key]);\n    }\n}\nconst FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nclass ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nclass Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nclass EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nclass ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nclass FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nclass ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ3dDO0FBQ007QUFDWjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZDQUE2QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0RBQWdELHlEQUFNO0FBQ3REO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBELHlEQUFNO0FBQ2hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlFQUF5RSx5REFBTTtBQUMvRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0RBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0RBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vZnJhZ21lbnRzLmpzP2ZmYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xubGV0IE1vZGlmaWVyc0J5dGVzID0geyBjYWxsZGF0YTogdHJ1ZSwgbWVtb3J5OiB0cnVlLCBzdG9yYWdlOiB0cnVlIH07XG5sZXQgTW9kaWZpZXJzTmVzdCA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSB9O1xuZnVuY3Rpb24gY2hlY2tNb2RpZmllcih0eXBlLCBuYW1lKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYnl0ZXNcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLmluZGV4T2YoXCJbXCIpID49IDAgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgIGlmIChNb2RpZmllcnNOZXN0W25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0gfHwgbmFtZSA9PT0gXCJwYXlhYmxlXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBAVE9ETzogTWFrZSBzdXJlIHRoYXQgY2hpbGRyZW4gb2YgYW4gaW5kZXhlZCB0dXBsZSBhcmUgbWFya2VkIHdpdGggYSBudWxsIGluZGV4ZWRcbmZ1bmN0aW9uIHBhcnNlUGFyYW1UeXBlKHBhcmFtLCBhbGxvd0luZGV4ZWQpIHtcbiAgICBsZXQgb3JpZ2luYWxQYXJhbSA9IHBhcmFtO1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IoaSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBwb3NpdGlvbiAke2l9YCwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgfVxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcbiAgICBmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCkge1xuICAgICAgICBsZXQgbm9kZSA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBwYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgICAgIGlmIChhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgIGxldCBub2RlID0gcGFyZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBwYXJhbVtpXTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSAmJiBub2RlLnR5cGUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93VHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSBbbmV3Tm9kZShub2RlKV07XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY29tcG9uZW50c1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmcgPSBuZXdOb2RlKG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICAvL3sgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgcGFyZW50OiBub2RlLnBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5jb21wb25lbnRzLnB1c2goc2libGluZyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSGl0IGEgc3BhY2UuLi5cbiAgICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICAgICAgLy8gSWYgcmVhZGluZyB0eXBlLCB0aGUgdHlwZSBpcyBkb25lIGFuZCBtYXkgcmVhZCBhIHBhcmFtIG9yIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgcmVhZGluZyBuYW1lLCB0aGUgbmFtZSBpcyBkb25lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUuYWxsb3dBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUucmVhZEFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLnJlYWRBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dBcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgZW9mXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgIH1cbiAgICBkZWxldGUgcGFyZW50LnN0YXRlO1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIHBhcmVudC50eXBlID0gdmVyaWZ5VHlwZShwYXJlbnQudHlwZSk7XG4gICAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBvcHVsYXRlKG9iamVjdCwgcGFyYW1zKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHBhcmFtcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seShvYmplY3QsIGtleSwgcGFyYW1zW2tleV0pO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBGb3JtYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8vIEJhcmUgZm9ybWF0dGluZywgYXMgaXMgbmVlZGVkIGZvciBjb21wdXRpbmcgYSBzaWdoYXNoIG9mIGFuIGV2ZW50IG9yIGZ1bmN0aW9uXG4gICAgc2lnaGFzaDogXCJzaWdoYXNoXCIsXG4gICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBNaW5pbWFsIHNwYWNpbmcgYW5kIHdpdGhvdXQgbmFtZXMgKGNvbXBhY3QgaHVtYW4tcmVhZGFibGUpXG4gICAgbWluaW1hbDogXCJtaW5pbWFsXCIsXG4gICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBuaWNlIHNwYWNpbmcsIGluY2x1ZGluZyBhbGwgbmFtZXNcbiAgICBmdWxsOiBcImZ1bGxcIixcbiAgICAvLyBKU09OLWZvcm1hdCBhIGxhIFNvbGlkaXR5XG4gICAganNvbjogXCJqc29uXCJcbn0pO1xuY29uc3QgcGFyYW1UeXBlQXJyYXkgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2UgZnJvbVN0cmluZ1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgUGFyYW1UeXBlKClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGUodGhpcywgcGFyYW1zKTtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiLTFcIiksXG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbjogUGFyYW1UeXBlLmZyb21PYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYmFzZVR5cGU6IFwiYXJyYXlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IG51bGwsXG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBiYXNlVHlwZTogKCh0aGlzLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhcmFtVHlwZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIC8vIEZvcm1hdCB0aGUgcGFyYW1ldGVyIGZyYWdtZW50XG4gICAgLy8gICAtIHNpZ2hhc2g6IFwiKHVpbnQyNTYsYWRkcmVzcylcIlxuICAgIC8vICAgLSBtaW5pbWFsOiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiXG4gICAgLy8gICAtIGZ1bGw6ICAgIFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWU6ICh0aGlzLm5hbWUgfHwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBKU09OLnBhcnNlKGNvbXAuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgKHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSkgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tU3RyaW5nKHZhbHVlLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2NvbnN0cnVjdG9yR3VhcmQsIHtcbiAgICAgICAgICAgIG5hbWU6ICh2YWx1ZS5uYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgdHlwZTogdmVyaWZ5VHlwZSh2YWx1ZS50eXBlKSxcbiAgICAgICAgICAgIGluZGV4ZWQ6ICgodmFsdWUuaW5kZXhlZCA9PSBudWxsKSA/IG51bGwgOiAhIXZhbHVlLmluZGV4ZWQpLFxuICAgICAgICAgICAgY29tcG9uZW50czogKHZhbHVlLmNvbXBvbmVudHMgPyB2YWx1ZS5jb21wb25lbnRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBmdW5jdGlvbiBQYXJhbVR5cGlmeShub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXhlZDogbm9kZS5pbmRleGVkLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG5vZGUuY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcmFtVHlwaWZ5KHBhcnNlUGFyYW1UeXBlKHZhbHVlLCAhIWFsbG93SW5kZXhlZCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX2lzUGFyYW1UeXBlKTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBwYXJzZVBhcmFtcyh2YWx1ZSwgYWxsb3dJbmRleCkge1xuICAgIHJldHVybiBzcGxpdE5lc3RpbmcodmFsdWUpLm1hcCgocGFyYW0pID0+IFBhcmFtVHlwZS5mcm9tU3RyaW5nKHBhcmFtLCBhbGxvd0luZGV4KSk7XG59XG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGEgc3RhdGljIGZyb20gbWV0aG9kXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGcmFnbWVudCgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IFNvbWV0aGluZz8gTWF5YmUgcmV0dXJuIGEgRnVuY3Rpb25GcmFnbWVudD8gQSBjdXN0b20gRGVmYXVsdEZ1bmN0aW9uRnJhZ21lbnQ/XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZyYWdtZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBcInJldHVybnNcIiBpcyBzdXJyb3VuZGVkIGJ5IGEgc3BhY2UgYW5kIGFsbCB3aGl0ZXNwYWNlIGlzIGV4YWN0bHkgb25lIHNwYWNlXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXCgvZywgXCIgKFwiKS5yZXBsYWNlKC9cXCkvZywgXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIihcIilbMF0udHJpbSgpID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGZyYWdtZW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZXZlbnQgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImFub255bW91cyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNFdmVudEZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgYW5vbnltb3VzOiB2YWx1ZS5hbm9ueW1vdXMsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFub255bW91cyA9IGZhbHNlO1xuICAgICAgICBtYXRjaFszXS5zcGxpdChcIiBcIikuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFub255bW91c1wiOlxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IG1hdGNoWzFdLnRyaW0oKSxcbiAgICAgICAgICAgIGFub255bW91czogYW5vbnltb3VzLFxuICAgICAgICAgICAgaW5wdXRzOiBwYXJzZVBhcmFtcyhtYXRjaFsyXSwgdHJ1ZSksXG4gICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0V2ZW50RnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImV2ZW50XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZ2FzID0gbnVsbDtcbiAgICBsZXQgY29tcHMgPSB2YWx1ZS5zcGxpdChcIkBcIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlIGdhc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuZ2FzID0gQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pO1xuICAgICAgICByZXR1cm4gY29tcHNbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuY29uc3RhbnQgPSBmYWxzZTtcbiAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICB2YWx1ZS5zcGxpdChcIiBcIikuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RpZmllci50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdGFudFwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGF5YWJsZVwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibm9ucGF5YWJsZVwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInB1cmVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInB1cmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2aWV3XCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdmVyaWZ5U3RhdGUodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBjb25zdGFudDogZmFsc2UsXG4gICAgICAgIHBheWFibGU6IHRydWUsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCJcbiAgICB9O1xuICAgIGlmICh2YWx1ZS5zdGF0ZU11dGFiaWxpdHkgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gdmFsdWUuc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBjb25zdGFudCBwcm9wZXJ0eVxuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCghIXZhbHVlLmNvbnN0YW50KSAhPT0gcmVzdWx0LmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCAoYW5kIGNoZWNrIHRoaW5ncyBhcmUgY29uc2lzdGVudCkgdGhlIHBheWFibGUgcHJvcGVydHlcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKCEhdmFsdWUucGF5YWJsZSkgIT09IHJlc3VsdC5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIHBheWFibGUgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiICsgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gISF2YWx1ZS5wYXlhYmxlO1xuICAgICAgICAvLyBJZiBwYXlhYmxlIHdlIGNhbiBhc3N1bWUgbm9uLWNvbnN0YW50OyBvdGhlcndpc2Ugd2UgY2FuJ3QgYXNzdW1lXG4gICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCA9PSBudWxsICYmICFyZXN1bHQucGF5YWJsZSAmJiB2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuICAgICAgICBpZiAocmVzdWx0LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5wYXlhYmxlICYmIHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IHBheWFibGUgZnVuY3Rpb25cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUuY29uc3RhbnQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuICAgICAgICByZXN1bHQucGF5YWJsZSA9ICFyZXN1bHQuY29uc3RhbnQ7XG4gICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSAocmVzdWx0LmNvbnN0YW50ID8gXCJ2aWV3XCIgOiBcInBheWFibGVcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcImNvbnN0cnVjdG9yKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAmJiB0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnN0YW50KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY29uc3RydWN0b3IgY2Fubm90IGJlIGNvbnN0YW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG4gICAgICAgICAgICBnYXM6ICh2YWx1ZS5nYXMgPyBCaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpIDogbnVsbClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImNvbnN0cnVjdG9yXCIgfTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHBhcmVucyA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucyB8fCBwYXJlbnNbMV0udHJpbSgpICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLnRyaW0oKSwgZmFsc2UpO1xuICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgQ29uc3RydWN0b3JGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gSlNPTi5wYXJzZShvdXRwdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJmdW5jdGlvbiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ2aWV3IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwicmV0dXJucyAoXCIgKyB0aGlzLm91dHB1dHMubWFwKChvdXRwdXQpID0+IG91dHB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbihcIiwgXCIpICsgXCIpIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJAXCIgKyB0aGlzLmdhcy50b1N0cmluZygpICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGNvbnN0YW50OiBzdGF0ZS5jb25zdGFudCxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgb3V0cHV0czogKHZhbHVlLm91dHB1dHMgPyB2YWx1ZS5vdXRwdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG4gICAgICAgICAgICBnYXM6ICh2YWx1ZS5nYXMgPyBCaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpIDogbnVsbClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImZ1bmN0aW9uXCIgfTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIgcmV0dXJucyBcIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVucyA9IGNvbXBzWzBdLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICB2ZXJpZnlJZGVudGlmaWVyKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCksIHBhcmFtcyk7XG4gICAgICAgIC8vIFdlIGhhdmUgb3V0cHV0c1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IHJldHVybnMgPSBjb21wc1sxXS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5zWzFdLnRyaW0oKSAhPSBcIlwiIHx8IHJldHVybnNbM10udHJpbSgpICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCB0b2tlbnNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IHBhcnNlUGFyYW1zKHJldHVybnNbMl0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGdW5jdGlvbkZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9XG59XG4vL2V4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbi8vfVxuZnVuY3Rpb24gY2hlY2tGb3JiaWRkZW4oZnJhZ21lbnQpIHtcbiAgICBjb25zdCBzaWcgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICBpZiAoc2lnID09PSBcIkVycm9yKHN0cmluZylcIiB8fCBzaWcgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjYW5ub3Qgc3BlY2lmeSB1c2VyIGRlZmluZWQgJHtzaWd9IGVycm9yYCwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJlcnJvciBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRXJyb3JGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBlcnJvciBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JiaWRkZW4obmV3IEVycm9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgcGFyYW1zID0geyB0eXBlOiBcImVycm9yXCIgfTtcbiAgICAgICAgbGV0IHBhcmVucyA9IHZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICBpZiAoIXBhcmVucykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICB2ZXJpZnlJZGVudGlmaWVyKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjaGVja0ZvcmJpZGRlbihFcnJvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Vycm9yRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImVycm9yXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZlcmlmeVR5cGUodHlwZSkge1xuICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdG8gdGhlaXIgZnVsbCBkZXNjcmlwdGlvblxuICAgIGlmICh0eXBlLm1hdGNoKC9edWludCgkfFteMS05XSkvKSkge1xuICAgICAgICB0eXBlID0gXCJ1aW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5tYXRjaCgvXmludCgkfFteMS05XSkvKSkge1xuICAgICAgICB0eXBlID0gXCJpbnQyNTZcIiArIHR5cGUuc3Vic3RyaW5nKDMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogbW9yZSB2ZXJpZmljYXRpb25cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3NvbGlkaXR5L2Jsb2IvMWY4ZjFhM2RiOTNhNTQ4ZDA1NTVlM2UxNGNmYzU1YTEwZTI1YjYwZS9kb2NzL2dyYW1tYXIvU29saWRpdHlMZXhlci5nNCNMMjM0XG5jb25zdCByZWdleElkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlthLXpBLVokX11bYS16QS1aMC05JF9dKiRcIik7XG5mdW5jdGlvbiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubWF0Y2gocmVnZXhJZGVudGlmaWVyKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXIgXCIke3ZhbHVlfVwiYCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHJlZ2V4UGFyZW4gPSBuZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7XG5mdW5jdGlvbiBzcGxpdE5lc3RpbmcodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IGFjY3VtID0gXCJcIjtcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHZhbHVlLmxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgbGV0IGMgPSB2YWx1ZVtvZmZzZXRdO1xuICAgICAgICBpZiAoYyA9PT0gXCIsXCIgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcbiAgICAgICAgICAgIGFjY3VtID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtICs9IGM7XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYmFsYW5jZWQgcGFyZW50aGVzaXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhY2N1bSkge1xuICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/fragments.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/id.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nclass LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nconst BuiltinErrors = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n};\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nclass Interface {\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragments\", abi.map((fragment) => {\n            return _fragments__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_abiCoder\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getAbiCoder\")());\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"errors\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"events\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", _fragments__WEBPACK_IMPORTED_MODULE_4__.ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.full;\n        }\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.json) {\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return _abi_coder__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);\n    }\n    static getSighash(fragment) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(fragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_4__.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            const getSighash = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment) {\n        if (typeof (fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            }\n            catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                }\n                catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\")(fragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        let reason = null;\n        let message = \"\";\n        let errorArgs = null;\n        let errorName = null;\n        let errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4: {\n                const selector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) {\n                        reason = errorArgs[0];\n                    }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;\n                    }\n                    else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;\n                    }\n                }\n                else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    }\n                    catch (error) { }\n                }\n                break;\n            }\n        }\n        return logger.throwError(\"call revert exception\" + message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            if (param.type.match(/^u?int/)) {\n                value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\"address\"], [value]);\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value), 32);\n        };\n        values.forEach((value, index) => {\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_4__.ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }\n                    });\n                }\n                else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${i}`, value); }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(tx.value || \"0\"),\n        });\n    }\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    parseError(data) {\n        const hexData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n}\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ3VDO0FBQ0M7QUFDbUQ7QUFDL0Q7QUFDWTtBQUM4QjtBQUNyQztBQUNjO0FBQ3lEO0FBQ3RFO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDSjtBQUN0Qiw2QkFBNkIsa0VBQVc7QUFDL0M7QUFDTyxxQ0FBcUMsa0VBQVc7QUFDdkQ7QUFDTywrQkFBK0Isa0VBQVc7QUFDakQ7QUFDTyxzQkFBc0Isa0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakcsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxxRkFBcUYsU0FBUztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sYUFBYSw2QkFBNkIsTUFBTSx5QkFBeUI7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUssMkJBQTJCLElBQUk7QUFDekM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUVBQWM7QUFDdEIsbUJBQW1CLGdEQUFRO0FBQzNCLFNBQVM7QUFDVCxRQUFRLHlFQUFjLG9CQUFvQixvRUFBUztBQUNuRCxRQUFRLHlFQUFjLHNCQUFzQjtBQUM1QyxRQUFRLHlFQUFjLG1CQUFtQjtBQUN6QyxRQUFRLHlFQUFjLG1CQUFtQjtBQUN6QyxRQUFRLHlFQUFjLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSx5RUFBYyxpQkFBaUIsMkRBQW1CO0FBQzlEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBVztBQUNoQztBQUNBLHVCQUF1QixtREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFlO0FBQzlCO0FBQ0E7QUFDQSxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLGtFQUFZLENBQUMsdURBQUU7QUFDOUI7QUFDQTtBQUNBLGVBQWUsdURBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdEQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBVztBQUN2QiwrQkFBK0Isb0VBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9FQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOERBQVE7QUFDOUIsWUFBWSw2REFBTztBQUNuQiw2RUFBNkUsY0FBYyxZQUFZLDZEQUFPO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBTyxDQUFDLDREQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUTtBQUM5QixZQUFZLDZEQUFPO0FBQ25CLGdGQUFnRixzQkFBc0IsWUFBWSw2REFBTztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBTyxDQUFDLDREQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2REFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUVBQXlFLDZCQUE2QjtBQUMzSTtBQUNBO0FBQ0EscUNBQXFDLHNFQUFzRSxhQUFhO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UseURBQU07QUFDMUU7QUFDQSxrQkFBa0IsNkRBQU87QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YseURBQU07QUFDeEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBRTtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFTLENBQUMsNkRBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFVLENBQUMsNkRBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBRTtBQUNsQztBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpRUFBVztBQUM1Qiw2REFBNkQseURBQU0sNEJBQTRCLDhEQUE4RDtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQVMsY0FBYyxtQ0FBbUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4RUFBOEUsNERBQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBO0FBQ0Esa0RBQWtELHVEQUF1RDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQ0FBa0MsMkJBQTJCO0FBQ2xHLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsRUFBRTtBQUNsRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9pbnRlcmZhY2UuanM/Y2UwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIERlc2NyaXB0aW9uLCBnZXRTdGF0aWMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycyB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRm9ybWF0VHlwZXMsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH07XG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEluZGV4ZWQgZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxufVxuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjogeyBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLCBuYW1lOiBcIkVycm9yXCIsIGlucHV0czogW1wic3RyaW5nXCJdLCByZWFzb246IHRydWUgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjogeyBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIiwgbmFtZTogXCJQYW5pY1wiLCBpbnB1dHM6IFtcInVpbnQyNTZcIl0gfVxufTtcbmZ1bmN0aW9uIHdyYXBBY2Nlc3NFcnJvcihwcm9wZXJ0eSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtwcm9wZXJ0eX1gKTtcbiAgICB3cmFwLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIHdyYXA7XG59XG4vKlxuZnVuY3Rpb24gY2hlY2tOYW1lcyhmcmFnbWVudDogRnJhZ21lbnQsIHR5cGU6IFwiaW5wdXRcIiB8IFwib3V0cHV0XCIsIHBhcmFtczogQXJyYXk8UGFyYW1UeXBlPik6IHZvaWQge1xuICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuICAgICAgICBpZiAocGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFjY3VtW3BhcmFtLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgPHsgWyBuYW1lOiBzdHJpbmcgXTogYm9vbGVhbiB9PnsgfSk7XG59XG4qL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG4gICAgICAgIH0pLmZpbHRlcigoZnJhZ21lbnQpID0+IChmcmFnbWVudCAhPSBudWxsKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hYmlDb2RlclwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRBYmlDb2RlclwiKSgpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzdHJ1Y3RzXCIsIHt9KTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJkZXBsb3lcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXRbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oe1xuICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzSW50ZXJmYWNlXCIsIHRydWUpO1xuICAgIH1cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5mdWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnRlcmZhY2UgZG9lcyBub3Qgc3VwcG9ydCBmb3JtYXR0aW5nIHNpZ2hhc2hcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGZyYWdtZW50KSA9PiBmcmFnbWVudC5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8vIFN1Yi1jbGFzc2VzIGNhbiBvdmVycmlkZSB0aGVzZSB0byBoYW5kbGUgb3RoZXIgYmxvY2tjaGFpbnNcbiAgICBzdGF0aWMgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWJpQ29kZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBoZXhEYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RnVuY3Rpb24obmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSB0aGlzLmdldFNpZ2hhc2gobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGZ1bmN0aW9uc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZnVuY3Rpb25zW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgIGdldEV2ZW50KG5hbWVPclNpZ25hdHVyZU9yVG9waWMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BpY2hhc2ggPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9waWNoYXNoID09PSB0aGlzLmdldEV2ZW50VG9waWMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcInRvcGljaGFzaFwiLCB0b3BpY2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclRvcGljLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKChmKSA9PiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV2ZW50c1tFdmVudEZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yVG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXJyb3IobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRTaWdoYXNoID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gZ2V0U2lnaGFzaChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGVycm9yc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXJyb3JzW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc2lnaGFzaCAodGhlIGJ5dGVzNCBzZWxlY3RvcikgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgZ2V0U2lnaGFzaChmcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKShmcmFnbWVudCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICBnZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuICAgIH1cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmdW5jdGlvbkZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBoZXhsaWZ5KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCksXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIHJlc3VsdCBmcm9tIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiBmcm9tIGV0aF9jYWxsKVxuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBsZXQgZXJyb3JBcmdzID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yTmFtZSA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvclNpZ25hdHVyZSA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoYnl0ZXMubGVuZ3RoICUgdGhpcy5fYWJpQ29kZXIuX2dldFdvcmRTaXplKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWlsdGluID0gQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JBcmdzID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGJ1aWx0aW4uaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGJ1aWx0aW4ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBidWlsdGluLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4ucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBlcnJvckFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTmFtZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYDsgVk0gRXhjZXB0aW9uIHdoaWxlIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246IHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGVycm9yQXJnc1swXSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvck5hbWUgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGA7IFZNIEV4Y2VwdGlvbiB3aGlsZSBwcm9jZXNzaW5nIHRyYW5zYWN0aW9uOiByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgJHtlcnJvckFyZ3NbMF19YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFyZ3MgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZXJyb3IuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck5hbWUgPSBlcnJvci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBlcnJvci5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYWxsIHJldmVydCBleGNlcHRpb25cIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksIGVycm9yQXJncywgZXJyb3JOYW1lLCBlcnJvclNpZ25hdHVyZSwgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuX2FiaUNvZGVyLmVuY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIgKyBldmVudEZyYWdtZW50LmZvcm1hdCgpLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGV2ZW50RnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZXZlbnRGcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgbGV0IHRvcGljSGFzaCA9IHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KTtcbiAgICAgICAgICAgIGlmICghaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgfHwgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgIT09IHRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInRvcGljc1swXVwiLCBleHBlY3RlZDogdG9waWNIYXNoLCB2YWx1ZTogdG9waWNzWzBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleGVkID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkID0gW107XG4gICAgICAgIGxldCBkeW5hbWljID0gW107XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbU9iamVjdCh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgbGV0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGtleXdvcmQgYXJndW1lbnQgaWYgbmFtZWQgYW5kIHNhZmVcbiAgICAgICAgICAgIGlmIChwYXJhbS5uYW1lICYmIHJlc3VsdFtwYXJhbS5uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgZXJyb3IgbmFtZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KHBhcmFtLm5hbWUpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwYXJhbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2UgYWxsIGVycm9yIGluZGV4ZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaV07XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihgaW5kZXggJHtpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdHJhbnNhY3Rpb24sIGZpbmQgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGZyYWdtZW50IChpZiBhbnkpIGFuZFxuICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIGNhbGwgcGFyYW1ldGVyc1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbih0eC5kYXRhLnN1YnN0cmluZygwLCAxMCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyB0eC5kYXRhLnN1YnN0cmluZygxMCkpLFxuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHNpZ2hhc2g6IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCksXG4gICAgICAgICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20odHgudmFsdWUgfHwgXCIwXCIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE9cbiAgICAvL3BhcnNlQ2FsbFJlc3VsdChkYXRhOiBCeXRlc0xpa2UpOiA/P1xuICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG4gICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGhleERhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIGhleERhdGEuc3Vic3RyaW5nKDEwKSksXG4gICAgICAgICAgICBlcnJvckZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgc3RhdGljIGZyb20odmFsdWU6IEFycmF5PEZyYWdtZW50IHwgc3RyaW5nIHwgSnNvbkFiaT4gfCBzdHJpbmcgfCBJbnRlcmZhY2UpIHtcbiAgICAgICAgaWYgKEludGVyZmFjZS5pc0ludGVyZmFjZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG4gICAgKi9cbiAgICBzdGF0aWMgaXNJbnRlcmZhY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ludGVyZmFjZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abi/lib.esm/interface.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-provider/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzPzBjMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFic3RyYWN0LXByb3ZpZGVyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockForkEvent: () => (/* binding */ BlockForkEvent),\n/* harmony export */   ForkEvent: () => (/* binding */ ForkEvent),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   TransactionForkEvent: () => (/* binding */ TransactionForkEvent),\n/* harmony export */   TransactionOrderForkEvent: () => (/* binding */ TransactionOrderForkEvent)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3FEO0FBQ0Y7QUFDd0M7QUFDNUM7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGtFQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsaUVBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLGlFQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxpRUFBVztBQUN4QjtBQUNBO0FBQ0EsYUFBYSxpRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCLFFBQVEsNEVBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrREFBUztBQUNoRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXIvbGliLmVzbS9pbmRleC5qcz8wZTFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgRGVzY3JpcHRpb24sIGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vL2V4cG9ydCB0eXBlIENhbGxUcmFuc2FjdGlvbmFibGUgPSB7XG4vLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuLy99O1xuZXhwb3J0IGNsYXNzIEZvcmtFdmVudCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNGb3JrRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZvcmtFdmVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJsb2NrRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0hhc2gsIGV4cGlyeSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJsb2NrSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNCbG9ja0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogYmxvY2tIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiaGFzaFwiLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJlZm9yZUhhc2gsIGFmdGVySGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYmVmb3JlSGFzaFwiLCBiZWZvcmVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYWZ0ZXJIYXNoXCIsIGFmdGVySGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJlZm9yZUhhc2g6IGJlZm9yZUhhc2gsXG4gICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRlZCBBYnN0cmFjdHNcbmV4cG9ydCBjbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2ssIGdhc1ByaWNlIH0gPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IHRoaXMuZ2V0QmxvY2soXCJsYXRlc3RcIiksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHRoaXMuZ2V0R2FzUHJpY2UoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoeSBpcyB0aGlzIG5vdyBmYWlsaW5nIG9uIENhbGF2ZXJhcz9cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsYXN0QmFzZUZlZVBlckdhcyA9IG51bGwsIG1heEZlZVBlckdhcyA9IG51bGwsIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG1vcmUgYWNjdXJhdGVseSBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBmb3JtdWxhIFwiY2hlY2sgaWYgdGhlIGJhc2UgZmVlIGlzIGNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1OVxuICAgICAgICAgICAgICAgIGxhc3RCYXNlRmVlUGVyR2FzID0gYmxvY2suYmFzZUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKFwiMTUwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzLm11bCgyKS5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbGFzdEJhc2VGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGdhc1ByaWNlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUHJvdmlkZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1Byb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-signer/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vX3ZlcnNpb24uanM/NDFmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst allowedTransactionKeys = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nconst forwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"call\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error) => { });\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            }\n            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            }\n            else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            }\n            else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        }\n                        else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    }\n                    else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            logger.throwError(\"network does not support EIP-1559\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    }\n                    else {\n                        // getFeeData has failed us.\n                        logger.throwError(\"failed to get consistent fee data\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                }\n                else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            }\n            else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results) => {\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider) {\n        super();\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDMkY7QUFDNUM7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQU07QUFDVixJQUFJLHlEQUFNO0FBQ1YsSUFBSSx5REFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RUFBaUI7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RUFBaUI7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0VBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseURBQU07QUFDekY7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UseURBQU07QUFDckY7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHVEQUF1RCx5REFBTTtBQUNoSTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5Qiw0RUFBaUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseURBQU07QUFDeEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QixRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBTSxpQ0FBaUMsc0JBQXNCO0FBQ3BHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9pbmRleC5qcz9mNjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSBbXG4gICAgXCJhY2Nlc3NMaXN0XCIsIFwiY2NpcFJlYWRFbmFibGVkXCIsIFwiY2hhaW5JZFwiLCBcImN1c3RvbURhdGFcIiwgXCJkYXRhXCIsIFwiZnJvbVwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ0eXBlXCIsIFwidmFsdWVcIlxuXTtcbmNvbnN0IGZvcndhcmRFcnJvcnMgPSBbXG4gICAgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG5dO1xuO1xuO1xuZXhwb3J0IGNsYXNzIFNpZ25lciB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCBzdXBlclxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LCBTaWduZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25lclwiLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1BWSBvdmVycmlkZSB0aGVzZVxuICAgIGdldEJhbGFuY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0QmFsYW5jZSh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldFRyYW5zYWN0aW9uQ291bnRcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBlc3RpbWF0ZXMgdGhlIGdhcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBjYWxscyB3aXRoIHRoZSB0cmFuc2FjdGlvblxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUeCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldENoYWluSWRcIik7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0R2FzUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0R2FzUHJpY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRGZWVEYXRhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcbiAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuICAgIC8vIC0gZG9lcyBOT1QgcmVxdWlyZSBhIHByb3ZpZGVyXG4gICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG4gICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gY2FsbFxuICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuICAgIC8vICAgLSBwb3B1bGF0ZVRyYW5zYWN0aW9uIChhbmQgdGhlcmVmb3Igc2VuZFRyYW5zYWN0aW9uKVxuICAgIGNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkVHJhbnNhY3Rpb25LZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHR4LmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwcm92aWRlZCBhZGRyZXNzIG1hdGNoZXMgdGhpcyBzaWduZXJcbiAgICAgICAgICAgIHR4LmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmZyb20pLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICBdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdLnRvTG93ZXJDYXNlKCkgIT09IHJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBBTEwga2V5cyBmb3IgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tzIHRoYXQgXCJmcm9tXCIgbWF0Y2hlc1xuICAgIC8vIHRoaXMgU2lnbmVyLiBTaG91bGQgYmUgdXNlZCBieSBzZW5kVHJhbnNhY3Rpb24gYnV0IE5PVCBieSBzaWduVHJhbnNhY3Rpb24uXG4gICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG4gICAgLy8gICAtIHNlbmRUcmFuc2FjdGlvblxuICAgIC8vXG4gICAgLy8gTm90ZXM6XG4gICAgLy8gIC0gV2UgYWxsb3cgZ2FzUHJpY2UgZm9yIEVJUC0xNTU5IGFzIGxvbmcgYXMgaXQgbWF0Y2hlcyBtYXhGZWVQZXJHYXNcbiAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbigodG8pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVkIEVOUyBuYW1lIHJlc29sdmVzIHRvIG51bGxcIiwgXCJ0eC50b1wiLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGhpcyBlcnJvciBmcm9tIGNhdXNpbmcgYW4gVW5oYW5kbGVkUHJvbWlzZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHR4LnRvLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwgJiYgKHR4LnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09IDIgfHwgdHgudHlwZSA9PSBudWxsKSAmJiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDAgfHwgdHgudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IHRoaXMuZ2V0R2FzUHJpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmICh0eC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHgubm9uY2UgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IHRoaXMuZXN0aW1hdGVHYXModHgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZEVycm9ycy5pbmRleE9mKGVycm9yLmNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHg6IHR4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcbiAgICAgICAgICAgICAgICBdKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzWzFdICE9PSAwICYmIHJlc3VsdHNbMF0gIT09IHJlc3VsdHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIFNIT1VMRCBsZWF2ZSB0aGVzZSBhbG9uZVxuICAgIF9jaGVja1Byb3ZpZGVyKG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaXNTaWduZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlciB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuICAgIH1cbiAgICBfZmFpbChtZXNzYWdlLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBvcGVyYXRpb24gfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgX3NpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHR5cGVkIGRhdGFcIiwgXCJzaWduVHlwZWREYXRhXCIpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"address/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcz9hY2RhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/address/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/address/lib.esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getContractAddress: () => (/* binding */ getContractAddress),\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress),\n/* harmony export */   isAddress: () => (/* binding */ isAddress)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/address/lib.esm/_version.js\");\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction getChecksumAddress(address) {\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([from, nonce])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2lHO0FBQy9CO0FBQzFCO0FBQ1Q7QUFDRztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0EsU0FBUyxpRUFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQiw4REFBUSxDQUFDLG1FQUFTO0FBQ3JDLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsWUFBWSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHFFQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQVUsQ0FBQyw4REFBUSxDQUFDLCtEQUFTO0FBQy9DLHNCQUFzQixrRUFBWSxDQUFDLG1FQUFTLENBQUMsMERBQU07QUFDbkQ7QUFDTztBQUNQLFFBQVEsbUVBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsbUVBQWE7QUFDckI7QUFDQTtBQUNBLHNCQUFzQixrRUFBWSxDQUFDLG1FQUFTLENBQUMsNERBQU07QUFDbkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9pbmRleC5qcz9kNzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBpc0hleFN0cmluZywgc3RyaXBaZXJvcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBfYmFzZTE2VG8zNiwgX2Jhc2UzNlRvMTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmxwXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXJyYXlpZnkoa2VjY2FrMjU2KGV4cGFuZGVkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcbn1cbi8vIFNoaW1zIGZvciBlbnZpcm9ubWVudHMgdGhhdCBhcmUgbWlzc2luZyBzb21lIHJlcXVpcmVkIGNvbnN0YW50cyBhbmQgZnVuY3Rpb25zXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICBpZiAoTWF0aC5sb2cxMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuY29uc3Qgc2FmZURpZ2l0cyA9IE1hdGguZmxvb3IobG9nMTAoTUFYX1NBRkVfSU5URUdFUikpO1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgJiYgcmVzdWx0ICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9iYXNlMzZUbzE2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGZyb20gPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGZyb20gPSBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgZnJvbSBhZGRyZXNzXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHN0cmlwWmVyb3MoYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZShbZnJvbSwgbm9uY2VdKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG4gICAgaWYgKGhleERhdGFMZW5ndGgoc2FsdCkgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIHNhbHQpO1xuICAgIH1cbiAgICBpZiAoaGV4RGF0YUxlbmd0aChpbml0Q29kZUhhc2gpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgaW5pdENvZGVIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBnZXRBZGRyZXNzKGZyb20pLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\nfunction decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n}\nfunction encode(data) {\n    data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2U2NC9saWIuZXNtL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNtQztBQUN6QztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLDhEQUFRO0FBQ25CO0FBQ087QUFDUCxXQUFXLDhEQUFRO0FBQ25CO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzPzAyYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBkYXRhID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/base64/lib.esm/base64.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/basex/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base32: () => (/* binding */ Base32),\n/* harmony export */   Base58: () => (/* binding */ Base58),\n/* harmony export */   BaseX: () => (/* binding */ BaseX)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n\nclass BaseX {\n    constructor(alphabet) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"alphabet\", alphabet);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"base\", alphabet.length);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_alphabetMap\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2V4L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNXO0FBQ3BEO0FBQ1A7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYyx5QkFBeUI7QUFDL0MsUUFBUSx5RUFBYztBQUN0QjtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbURBQW1EO0FBQzNFO0FBQ0E7QUFDQSxlQUFlLDhEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQzBCO0FBQzFCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2V4L2xpYi5lc20vaW5kZXguanM/YjNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZhciBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGJhc2VkIG9uIGJhc2UteC4gVGhlIG1haW4gcmVhc29uIHRvXG4gKiBkZXZpYXRlIHdhcyB0byBwcmV2ZW50IHRoZSBkZXBlbmRlbmN5IG9mIEJ1ZmZlci5cbiAqXG4gKiBDb250cmlidXRvcnM6XG4gKlxuICogYmFzZS14IGVuY29kaW5nXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbiAqIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbiAqIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbiAqIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5leHBvcnQgY2xhc3MgQmFzZVgge1xuICAgIGNvbnN0cnVjdG9yKGFscGhhYmV0KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxwaGFiZXRcIiwgYWxwaGFiZXQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJhc2VcIiwgYWxwaGFiZXQubGVuZ3RoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9sZWFkZXJcIiwgYWxwaGFiZXQuY2hhckF0KDApKTtcbiAgICAgICAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhYmV0TWFwW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBsZXQgc291cmNlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0cyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjYXJyeSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICAgICAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIHRoaXMuYmFzZSk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHNvdXJjZVtrXSA9PT0gMCAmJiBrIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuX2xlYWRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgICAgICBmb3IgKGxldCBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hbHBoYWJldFtkaWdpdHNbcV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIGRlY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG4gICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYXJyeSA9IGJ5dGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyB2YWx1ZVtrXSA9PT0gdGhpcy5fbGVhZGVyICYmIGsgPCB2YWx1ZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSkpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuY29uc3QgQmFzZTU4ID0gbmV3IEJhc2VYKFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiKTtcbmV4cG9ydCB7IEJhc2UzMiwgQmFzZTU4IH07XG4vL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuLy9jb25zb2xlLmxvZyhCYXNlNTguZW5jb2RlKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/basex/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bignumber/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanM/NTllYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYmlnbnVtYmVyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   _base16To36: () => (/* binding */ _base16To36),\n/* harmony export */   _base36To16: () => (/* binding */ _base36To16),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nvar BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) ||\n        (typeof (value) === \"bigint\") ||\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return logger.throwError(\"this platform does not support BigInt\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {\n            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || (hex[0] === \"-\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n//# sourceMappingURL=bignumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dCO0FBQ3hCLFNBQVMsaURBQU07QUFDc0Q7QUFDdEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFXO0FBQ25CO0FBQ0EsUUFBUSw2REFBTztBQUNmO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUIseURBQU07QUFDNUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUseURBQU07QUFDaEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDhCQUE4Qix5REFBTSwrQkFBK0I7QUFDeko7QUFDQTtBQUNBLG1GQUFtRix5REFBTSwrQkFBK0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFPO0FBQ25CLGtDQUFrQyw2REFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFXLDRCQUE0QixpRUFBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFNO0FBQzFDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vYmlnbnVtYmVyLmpzPzNlODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGNhbGwgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBCaWdOdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgKEJpZ051bWJlcilcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGZyb21Ud29zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmZyb21Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIHRvVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKTtcbiAgICB9XG4gICAgYWJzKCkge1xuICAgICAgICBpZiAodGhpcy5faGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYWRkKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIHN1YihvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zdWIodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgZGl2KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG8gPSBCaWdOdW1iZXIuZnJvbShvdGhlcik7XG4gICAgICAgIGlmIChvLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcImRpdlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5kaXYodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbXVsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm11bCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBtb2Qob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJkaXZpc2lvbi1ieS16ZXJvXCIsIFwibW9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcbiAgICB9XG4gICAgcG93KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtcG93ZXJcIiwgXCJwb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHZhbHVlKSk7XG4gICAgfVxuICAgIGFuZChvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJhbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYW5kKHZhbHVlKSk7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiLCBcIm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfVxuICAgIG1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwibWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuICAgIH1cbiAgICBzaGwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9XG4gICAgc2hyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNoclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVjayAoU2VlOiAjODg5KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfd2FybmVkVG9TdHJpbmdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgYmFzZS0xMCBpcyBhc3N1bWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXJzXCIsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgfVxuICAgIHRvSlNPTihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJCaWdOdW1iZXJcIiwgaGV4OiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oYW55VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnl0ZXMoYW55VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4bGlmeShhbnlWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGhhbmRsZSBsZWdhY3kgSlNPTi1pZmllZCB2YWx1ZXMgKGdvZXMgYXdheSBpbiB2NilcbiAgICAgICAgICAgICAgICBsZXQgaGV4ID0gYW55VmFsdWUuX2hleDtcbiAgICAgICAgICAgICAgICAvLyBOZXctZm9ybSBKU09OXG4gICAgICAgICAgICAgICAgaWYgKGhleCA9PSBudWxsICYmIGFueVZhbHVlLnR5cGUgPT09IFwiQmlnTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYW55VmFsdWUuaGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhoZXgpIHx8IChoZXhbMF0gPT09IFwiLVwiICYmIGlzSGV4U3RyaW5nKGhleC5zdWJzdHJpbmcoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuICAgIH1cbn1cbi8vIE5vcm1hbGl6ZSB0aGUgaGV4IHN0cmluZ1xuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICAvLyBGb3IgQk4sIGNhbGwgb24gdGhlIGhleCBzdHJpbmdcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8vIElmIG5lZ2F0aXZlLCBwcmVwZW5kIHRoZSBuZWdhdGl2ZSBzaWduIHRvIHRoZSBub3JtYWxpemVkIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIG11bHRpcGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRvSGV4IG9uIHRoZSBwb3NpdGl2ZSBjb21wb25lbnRcbiAgICAgICAgdmFsdWUgPSB0b0hleCh2YWx1ZSk7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4MDBcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZ2F0ZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIC8vIEFkZCBhIFwiMHhcIiBwcmVmaXggaWYgbWlzc2luZ1xuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgemVyb1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICAvLyBUcmltIHRvIHNtYWxsZXN0IGV2ZW4tbGVuZ3RoIHN0cmluZ1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPiA0ICYmIHZhbHVlLnN1YnN0cmluZygwLCA0KSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCk7XG4gICAgaWYgKGhleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJOKGhleC5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbmZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGZhdWx0LCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTM2VG8xNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAzNikpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlMTZUbzM2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDE2KSkudG9TdHJpbmcoMzYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedFormat: () => (/* binding */ FixedFormat),\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber),\n/* harmony export */   formatFixed: () => (/* binding */ formatFixed),\n/* harmony export */   parseFixed: () => (/* binding */ parseFixed)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst _constructorGuard = {};\nconst Zero = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(whole);\n    const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nclass FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nclass FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !(0,_bignumber__WEBPACK_IMPORTED_MODULE_2__.isBigNumberish)(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2ZpeGVkbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDd0Q7QUFDdEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUN1QjtBQUN4RDtBQUNBLGFBQWEsaURBQVM7QUFDdEIsb0JBQW9CLGlEQUFTO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVM7QUFDaEMsMEJBQTBCLGlEQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1FQUFtRSx1QkFBdUIseURBQU07QUFDaEc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUVBQW1FLHVCQUF1Qix5REFBTTtBQUNoRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0IsZUFBZSxnRUFBVTtBQUN6QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBEQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBUTtBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2ZpeGVkbnVtYmVyLmpzP2Y2OTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBpc0JpZ051bWJlcmlzaCB9IGZyb20gXCIuL2JpZ251bWJlclwiO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmNvbnN0IFplcm8gPSBCaWdOdW1iZXIuZnJvbSgwKTtcbmNvbnN0IE5lZ2F0aXZlT25lID0gQmlnTnVtYmVyLmZyb20oLTEpO1xuZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IHplcm9zID0gXCIwXCI7XG53aGlsZSAoemVyb3MubGVuZ3RoIDwgMjU2KSB7XG4gICAgemVyb3MgKz0gemVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKSB7XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IEJpZ051bWJlci5mcm9tKGRlY2ltYWxzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpID09PSBcIm51bWJlclwiICYmIGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPD0gMjU2ICYmICEoZGVjaW1hbHMgJSAxKSkge1xuICAgICAgICByZXR1cm4gKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHNpemVcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgLy8gTWFrZSBzdXJlIHdlaSBpcyBhIGJpZyBudW1iZXIgKGNvbnZlcnQgYXMgbmVjZXNzYXJ5KVxuICAgIHZhbHVlID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFsdWUubHQoWmVybyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubXVsKE5lZ2F0aXZlT25lKTtcbiAgICB9XG4gICAgbGV0IGZyYWN0aW9uID0gdmFsdWUubW9kKG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiICsgZnJhY3Rpb247XG4gICAgfVxuICAgIC8vIFN0cmlwIHRyYWluaW5nIDBcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdO1xuICAgIGNvbnN0IHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG11bHRpcGxpZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gd2hvbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXi0/WzAtOS5dKyQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cbiAgICBjb25zdCBuZWdhdGl2ZSA9ICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IGl0IGludG8gYSB3aG9sZSBhbmQgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXSwgZnJhY3Rpb24gPSBjb21wc1sxXTtcbiAgICBpZiAoIXdob2xlKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGlmICghZnJhY3Rpb24pIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvc1xuICAgIHdoaWxlIChmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHJpbmcoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBmcmFjdGlvbiBkb2Vzbid0IGV4Y2VlZCBvdXIgZGVjaW1hbHMgc2l6ZVxuICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3dGYXVsdChcImZyYWN0aW9uYWwgY29tcG9uZW50IGV4Y2VlZHMgZGVjaW1hbHNcIiwgXCJ1bmRlcmZsb3dcIiwgXCJwYXJzZUZpeGVkXCIpO1xuICAgIH1cbiAgICAvLyBJZiBkZWNpbWFscyBpcyAwLCB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgZnJhY3Rpb25cbiAgICBpZiAoZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gRnVsbHkgcGFkIHRoZSBzdHJpbmcgd2l0aCB6ZXJvcyB0byBnZXQgdG8gd2VpXG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcbiAgICB9XG4gICAgY29uc3Qgd2hvbGVWYWx1ZSA9IEJpZ051bWJlci5mcm9tKHdob2xlKTtcbiAgICBjb25zdCBmcmFjdGlvblZhbHVlID0gQmlnTnVtYmVyLmZyb20oZnJhY3Rpb24pO1xuICAgIGxldCB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgd2VpID0gd2VpLm11bChOZWdhdGl2ZU9uZSk7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnQgY2xhc3MgRml4ZWRGb3JtYXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkRm9ybWF0IGNvbnN0cnVjdG9yOyB1c2UgRml4ZWRGb3JtYXQuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5kZWNpbWFscyA9IGRlY2ltYWxzO1xuICAgICAgICB0aGlzLm5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRml4ZWRGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gMTI4O1xuICAgICAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZVtrZXldKSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID4gODApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoZGVjaW1hbHMgdG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgaGV4LCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkTnVtYmVyIGNvbnN0cnVjdG9yOyB1c2UgRml4ZWROdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNGaXhlZE51bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIF9jaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQubmFtZSAhPT0gb3RoZXIuZm9ybWF0Lm5hbWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuYWRkKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBzdWJVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5zdWIoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIG11bFVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBkaXZVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLmRpdihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJVbnNhZmUoT05FLnRvRm9ybWF0KHJlc3VsdC5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZFVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTdXBwb3J0IG90aGVyIHJvdW5kaW5nIGFsZ29yaXRobXNcbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGluIHJhbmdlLCB3ZSdyZSBkb25lXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzIDwgMCB8fCBkZWNpbWFscyA+IDgwIHx8IChkZWNpbWFscyAlIDEpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IEZpeGVkTnVtYmVyLmZyb20oXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGJ1bXAgPSBCVU1QLnRvRm9ybWF0KHRoaXMuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsVW5zYWZlKGZhY3RvcikuYWRkVW5zYWZlKGJ1bXApLmZsb29yKCkuZGl2VW5zYWZlKGZhY3Rvcik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9PT0gXCIwLjBcIiB8fCB0aGlzLl92YWx1ZSA9PT0gXCIwXCIpO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlWzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICB0b0hleFN0cmluZyh3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggJSA4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoaGV4LCB3aWR0aCAvIDgpO1xuICAgIH1cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMuX3ZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIGRlY2ltYWxzIGxvb2tzIG1vcmUgbGlrZSBhIGZvcm1hdCwgYW5kIHRoZXJlIGlzIG5vIGZvcm1hdCwgc2hpZnQgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsICYmIGRlY2ltYWxzICE9IG51bGwgJiYgIWlzQmlnTnVtYmVyaXNoKGRlY2ltYWxzKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZGVjaW1hbHM7XG4gICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpLCBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuICAgICAgICBjb25zdCBudW1lcmljID0gcGFyc2VGaXhlZCh2YWx1ZSwgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBpZiAoIWZpeGVkRm9ybWF0LnNpZ25lZCAmJiBudW1lcmljLmx0KFplcm8pKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwib3ZlcmZsb3dcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhleCA9IG51bGw7XG4gICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9Ud29zKGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgaGV4ID0gaGV4WmVyb1BhZChoZXgsIGZpeGVkRm9ybWF0LndpZHRoIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXModmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgaWYgKGFycmF5aWZ5KHZhbHVlKS5sZW5ndGggPiBmaXhlZEZvcm1hdC53aWR0aCAvIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1lcmljID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4ID0gbnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZCA/IDAgOiAxKSArIGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICBjb25zdCBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgMCwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IE5VTUVSSUNfRkFVTFQgdG8gYnViYmxlIHVwXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGaXhlZE51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuICAgIH1cbn1cbmNvbnN0IE9ORSA9IEZpeGVkTnVtYmVyLmZyb20oMSk7XG5jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bytes/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzPzI1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJ5dGVzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   hexConcat: () => (/* binding */ hexConcat),\n/* harmony export */   hexDataLength: () => (/* binding */ hexDataLength),\n/* harmony export */   hexDataSlice: () => (/* binding */ hexDataSlice),\n/* harmony export */   hexStripZeros: () => (/* binding */ hexStripZeros),\n/* harmony export */   hexValue: () => (/* binding */ hexValue),\n/* harmony export */   hexZeroPad: () => (/* binding */ hexZeroPad),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   joinSignature: () => (/* binding */ joinSignature),\n/* harmony export */   splitSignature: () => (/* binding */ splitSignature),\n/* harmony export */   stripZeros: () => (/* binding */ stripZeros),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL2luZGV4LmpzPzgwMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUudG9IZXhTdHJpbmcpO1xufVxuZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBhcnJheS5zbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA9PSB2YWx1ZSAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpIHx8IHZhbHVlLmxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIodikgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuICAgIGNvbnN0IG9iamVjdHMgPSBpdGVtcy5tYXAoaXRlbSA9PiBhcnJheWlmeShpdGVtKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqZWN0cy5yZWR1Y2UoKGFjY3VtLCBpdGVtKSA9PiAoYWNjdW0gKyBpdGVtLmxlbmd0aCksIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgb2JqZWN0cy5yZWR1Y2UoKG9mZnNldCwgb2JqZWN0KSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgb2JqZWN0Lmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcbiAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDB4Zl0gKyBoZXg7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIweDBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qXG5mdW5jdGlvbiB1bm9kZGlmeSh2YWx1ZTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlcik6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIge1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhU2xpY2UoZGF0YSwgb2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG4gICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQsIDIgKyAyICogZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcbiAgICBpZiAodHJpbW1lZCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbW1lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHI6IFwiMHhcIixcbiAgICAgICAgczogXCIweFwiLFxuICAgICAgICBfdnM6IFwiMHhcIixcbiAgICAgICAgcmVjb3ZlcnlQYXJhbTogMCxcbiAgICAgICAgdjogMCxcbiAgICAgICAgeVBhcml0eUFuZFM6IFwiMHhcIixcbiAgICAgICAgY29tcGFjdDogXCIweFwiXG4gICAgfTtcbiAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeShzaWduYXR1cmUpO1xuICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIC8vIEVJUC0yMDk4OyBwdWxsIHRoZSB2IGZyb20gdGhlIHRvcCBiaXQgb2YgcyBhbmQgY2xlYXIgaXRcbiAgICAgICAgICAgIHJlc3VsdC52ID0gMjcgKyAoYnl0ZXNbMzJdID4+IDcpO1xuICAgICAgICAgICAgYnl0ZXNbMzJdICY9IDB4N2Y7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgIHJlc3VsdC52ID0gYnl0ZXNbNjRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZ1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuciA9IHNpZ25hdHVyZS5yO1xuICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcbiAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgLy8gYW5kIHZlcmlmeSBub24tbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9ICgodnNbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSB2IG1pc21hdGNoIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWNpZCBhbmQgdiB0byBwb3B1bGF0ZSBlYWNoIG90aGVyXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXJyYXlpZnkocmVzdWx0LnMpO1xuICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gX3ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC55UGFyaXR5QW5kUyA9IHJlc3VsdC5fdnM7XG4gICAgcmVzdWx0LmNvbXBhY3QgPSByZXN1bHQuciArIHJlc3VsdC55UGFyaXR5QW5kUy5zdWJzdHJpbmcoMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgc2lnbmF0dXJlLnIsXG4gICAgICAgIHNpZ25hdHVyZS5zLFxuICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuICAgIF0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressZero: () => (/* binding */ AddressZero)\n/* harmony export */ });\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcz8yZGVkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/constants/lib.esm/addresses.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: () => (/* binding */ MaxInt256),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   MinInt256: () => (/* binding */ MinInt256),\n/* harmony export */   NegativeOne: () => (/* binding */ NegativeOne),\n/* harmony export */   One: () => (/* binding */ One),\n/* harmony export */   Two: () => (/* binding */ Two),\n/* harmony export */   WeiPerEther: () => (/* binding */ WeiPerEther),\n/* harmony export */   Zero: () => (/* binding */ Zero)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\nconst NegativeOne = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1));\nconst Zero = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0));\nconst One = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1));\nconst Two = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2));\nconst WeiPerEther = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst MinInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\n//# sourceMappingURL=bignumbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2JpZ251bWJlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ3JELG1DQUFtQywrREFBUztBQUM1Qyw0QkFBNEIsK0RBQVM7QUFDckMsMkJBQTJCLCtEQUFTO0FBQ3BDLDJCQUEyQiwrREFBUztBQUNwQyxtQ0FBbUMsK0RBQVM7QUFDNUMsa0NBQWtDLCtEQUFTO0FBQzNDLGlDQUFpQywrREFBUztBQUMxQyxpQ0FBaUMsK0RBQVM7QUFDNkM7QUFDdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9iaWdudW1iZXJzLmpzPzJhNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuY29uc3QgTmVnYXRpdmVPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgtMSkpO1xuY29uc3QgWmVybyA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDApKTtcbmNvbnN0IE9uZSA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDEpKTtcbmNvbnN0IFR3byA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDIpKTtcbmNvbnN0IFdlaVBlckV0aGVyID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heFVpbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG5jb25zdCBNaW5JbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIi0weDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikpO1xuY29uc3QgTWF4SW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuZXhwb3J0IHsgTmVnYXRpdmVPbmUsIFplcm8sIE9uZSwgVHdvLCBXZWlQZXJFdGhlciwgTWF4VWludDI1NiwgTWluSW50MjU2LCBNYXhJbnQyNTYsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdudW1iZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashZero: () => (/* binding */ HashZero)\n/* harmony export */ });\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcz9lNDYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/constants/lib.esm/hashes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"hash/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9fdmVyc2lvbi5qcz9jODQ1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJoYXNoLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode_arithmetic: () => (/* binding */ decode_arithmetic),\n/* harmony export */   read_compressed_payload: () => (/* binding */ read_compressed_payload),\n/* harmony export */   read_emoji_trie: () => (/* binding */ read_emoji_trie),\n/* harmony export */   read_mapped_map: () => (/* binding */ read_mapped_map),\n/* harmony export */   read_member_array: () => (/* binding */ read_member_array),\n/* harmony export */   read_payload: () => (/* binding */ read_payload),\n/* harmony export */   read_zero_terminated_array: () => (/* binding */ read_zero_terminated_array),\n/* harmony export */   signed: () => (/* binding */ signed)\n/* harmony export */ });\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nfunction read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nfunction read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nfunction read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nfunction read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nfunction read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2RlY29kZXIuanM/ZmRhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlaG5hbW1vZGkvcG9seWZpbGwvYmxvYi9tYXN0ZXIvYXJyYXkucG9seWZpbGwuanNcbmZ1bmN0aW9uIGZsYXQoYXJyYXksIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBmb3JFYWNoID0gcmVzdWx0LmZvckVhY2g7XG4gICAgY29uc3QgZmxhdERlZXAgPSBmdW5jdGlvbiAoYXJyLCBkZXB0aCkge1xuICAgICAgICBmb3JFYWNoLmNhbGwoYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAwICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIGZsYXREZWVwKHZhbCwgZGVwdGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZmxhdERlZXAoYXJyYXksIGRlcHRoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbUVudHJpZXMoYXJyYXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIHJlc3VsdFt2YWx1ZVswXV0gPSB2YWx1ZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cbiAgICAvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxuICAgIGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcbiAgICBsZXQgdG90YWwgPSAxO1xuICAgIGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XG4gICAgICAgIGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcbiAgICB9XG4gICAgLy8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXG4gICAgbGV0IHNraXAgPSB1MTYoKTtcbiAgICBsZXQgcG9zX3BheWxvYWQgPSBwb3M7XG4gICAgcG9zICs9IHNraXA7XG4gICAgbGV0IHJlYWRfd2lkdGggPSAwO1xuICAgIGxldCByZWFkX2J1ZmZlciA9IDA7XG4gICAgZnVuY3Rpb24gcmVhZF9iaXQoKSB7XG4gICAgICAgIGlmIChyZWFkX3dpZHRoID09IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXG4gICAgICAgICAgICAvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxuICAgICAgICAgICAgcmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XG4gICAgICAgICAgICByZWFkX3dpZHRoID0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xuICAgIH1cbiAgICBjb25zdCBOID0gMzE7XG4gICAgY29uc3QgRlVMTCA9IE1hdGgucG93KDIsIE4pO1xuICAgIGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xuICAgIGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XG4gICAgY29uc3QgTUFTSyA9IEZVTEwgLSAxO1xuICAgIC8vIGZpbGwgcmVnaXN0ZXJcbiAgICBsZXQgcmVnaXN0ZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKVxuICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XG4gICAgbGV0IHN5bWJvbHMgPSBbXTtcbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcbiAgICAgICAgd2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXG4gICAgICAgICAgICBsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IDApXG4gICAgICAgICAgICBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXG4gICAgICAgIHN5bWJvbHMucHVzaChzdGFydCk7XG4gICAgICAgIGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gLyB0b3RhbCk7XG4gICAgICAgIGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCArIDFdIC8gdG90YWwpIC0gMTtcbiAgICAgICAgd2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xuICAgICAgICAgICAgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcbiAgICAgICAgICAgIGEgPSAoYSA8PCAxKSAmIE1BU0s7XG4gICAgICAgICAgICBiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYSAmIH5iICYgUVJUUikge1xuICAgICAgICAgICAgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcbiAgICAgICAgICAgIGEgPSAoYSA8PCAxKSBeIEhBTEY7XG4gICAgICAgICAgICBiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcbiAgICAgICAgfVxuICAgICAgICBsb3cgPSBhO1xuICAgICAgICByYW5nZSA9IDEgKyBiIC0gYTtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XG4gICAgcmV0dXJuIHN5bWJvbHMubWFwKHggPT4ge1xuICAgICAgICBzd2l0Y2ggKHggLSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHggLSAxO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXG5leHBvcnQgZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICByZXR1cm4gKCkgPT4gdltwb3MrK107XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSk7XG59XG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZChpKSB7XG4gICAgcmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcbn1cbmZ1bmN0aW9uIHJlYWRfY291bnRzKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICB2W2ldID0gMSArIG5leHQoKTtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfYXNjZW5kaW5nKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwLCB4ID0gLTE7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSB4ICs9IDEgKyBuZXh0KCk7XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XG4gICAgbGV0IHYgPSBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xuICAgIHJldHVybiB2O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfbWVtYmVyX2FycmF5KG5leHQsIGxvb2t1cCkge1xuICAgIGxldCB2ID0gcmVhZF9hc2NlbmRpbmcobmV4dCgpLCBuZXh0KTtcbiAgICBsZXQgbiA9IG5leHQoKTtcbiAgICBsZXQgdlggPSByZWFkX2FzY2VuZGluZyhuLCBuZXh0KTtcbiAgICBsZXQgdk4gPSByZWFkX2NvdW50cyhuLCBuZXh0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZOW2ldOyBqKyspIHtcbiAgICAgICAgICAgIHYucHVzaCh2WFtpXSArIGopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb29rdXAgPyB2Lm1hcCh4ID0+IGxvb2t1cFt4XSkgOiB2O1xufVxuLy8gcmV0dXJucyBhcnJheSBvZiBcbi8vIFt4LCB5c10gPT4gc2luZ2xlIHJlcGxhY2VtZW50IHJ1bGVcbi8vIFt4LCB5cywgbiwgZHgsIGR4XSA9PiBsaW5lYXIgbWFwXG5leHBvcnQgZnVuY3Rpb24gcmVhZF9tYXBwZWRfbWFwKG5leHQpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHcgPSBuZXh0KCk7XG4gICAgICAgIGlmICh3ID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdyA9IG5leHQoKSAtIDE7XG4gICAgICAgIGlmICh3IDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21FbnRyaWVzKGZsYXQocmV0KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF96ZXJvX3Rlcm1pbmF0ZWRfYXJyYXkobmV4dCkge1xuICAgIGxldCB2ID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGkgPSBuZXh0KCk7XG4gICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdi5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XG4gICAgbGV0IG0gPSBBcnJheShuKS5maWxsKHVuZGVmaW5lZCkubWFwKCgpID0+IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICByZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcbiAgICBsZXQgZHggPSAxICsgbmV4dCgpO1xuICAgIGxldCBkeSA9IG5leHQoKTtcbiAgICBsZXQgdk4gPSByZWFkX3plcm9fdGVybWluYXRlZF9hcnJheShuZXh0KTtcbiAgICBsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDEgKyB3LCBuZXh0KTtcbiAgICByZXR1cm4gZmxhdChtLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gdlswXSwgeXMgPSB2LnNsaWNlKDEpO1xuICAgICAgICAvL2xldCBbeCwgLi4ueXNdID0gdjtcbiAgICAgICAgLy9yZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKHVuZGVmaW5lZCkubWFwKChfLCBqKSA9PiB7XG4gICAgICAgICAgICBsZXQgal9keSA9IGogKiBkeTtcbiAgICAgICAgICAgIHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7XG4gICAgbGV0IG4gPSAxICsgbmV4dCgpO1xuICAgIGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDEgKyB3LCBuZXh0KTtcbiAgICByZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfZW1vamlfdHJpZShuZXh0KSB7XG4gICAgbGV0IHNvcnRlZCA9IHJlYWRfbWVtYmVyX2FycmF5KG5leHQpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICByZXR1cm4gcmVhZCgpO1xuICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIGxldCBicmFuY2hlcyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGtleXMgPSByZWFkX21lbWJlcl9hcnJheShuZXh0LCBzb3J0ZWQpO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBicmFuY2hlcy5wdXNoKHsgc2V0OiBuZXcgU2V0KGtleXMpLCBub2RlOiByZWFkKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT4gYi5zZXQuc2l6ZSAtIGEuc2V0LnNpemUpOyAvLyBzb3J0IGJ5IGxpa2VsaWhvb2RcbiAgICAgICAgbGV0IHRlbXAgPSBuZXh0KCk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRlbXAgJSAzO1xuICAgICAgICB0ZW1wID0gKHRlbXAgLyAzKSB8IDA7XG4gICAgICAgIGxldCBmZTBmID0gISEodGVtcCAmIDEpO1xuICAgICAgICB0ZW1wID4+PSAxO1xuICAgICAgICBsZXQgc2F2ZSA9IHRlbXAgPT0gMTtcbiAgICAgICAgbGV0IGNoZWNrID0gdGVtcCA9PSAyO1xuICAgICAgICByZXR1cm4geyBicmFuY2hlcywgdmFsaWQsIGZlMGYsIHNhdmUsIGNoZWNrIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getData: () => (/* binding */ getData)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../../node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nfunction getData() {\n    return (0,_decoder_js__WEBPACK_IMPORTED_MODULE_0__.read_compressed_payload)((0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__.decode)('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));\n}\n//# sourceMappingURL=include.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2luY2x1ZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDUTtBQUNoRDtBQUNQLFdBQVcsb0VBQXVCLENBQUMsNkRBQU07QUFDekM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2luY2x1ZGUuanM/Y2YzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgcmVhZF9jb21wcmVzc2VkX3BheWxvYWQgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKGRlY29kZSgnQUVRRjJBTzJERXNBMndJckFHc0JSQUJ4QU44QVp3Q2NBRXdBcWdBMEFHd0FVZ0J5QURjQVRBQVZBRllBSVFBeUFDRUFLQUFZQUZnQUd3QWpBQlFBTUFBbUFESUFGQUFmQUJRQUt3QVRBQ29BRGdBYkFBOEFIUUFZQUJvQUdRQXhBRGdBTEFBb0FEd0FFd0E5QUJNQUdnQVJBQTRBRHdBV0FCTUFGZ0FJQUE4QUhnUVhCWU1BNUJISkFTOEp0QVlvQWU0QUV4b3ppMFVBSDIxdEFhTW5CVDhDcm5JeWhyTURoUmdEeWdJQlVBRUhjb0ZIVVBlOEFYQmpBZXdDamdEUVI4SUlDSWNFY1FMd0FUWENEZ3p2SHdCbUJvSE5BcXNCZEJjVUF5a2dEaEFNU2hza01nbzhBWThqcUFRZkFVQWZIdzhCRHc4N01pb0dsQ0lQQndaQ2E0RUxhdE1BQU1zcEpWZ3NEbDhBSWhja1NnOFhBSGR2VHdCY0lRRWlEVDRPUGhVcWJ5RUNBRW9BUzM0QWVqOFlieDgzSmdUL1h3OGdIeFovN3c4UklDeFBIQTl2QncrUGZ3OFBId0FQRnYrZkFzQXZDYzh2RXI4aXZ3RC9FUThCb2w4T0VCYS9BNzhocndBUENVOHZFU052dndXZkh3TmZBVm9ESHIrWkFBRUQzNFlhQWRKUEFLN1BMd1NFZ0RMSEFHbzFQejhQdng5ZlV3TXJwYjhPLzU4VlR6QVBJQm9YSXlRSk5GOGhwd0lWQVQ4WUdBVUFERE5CYVgzUkFNb21KQ2c5RWhVZUEyOU1BQnNaQlRNTkppcGpPaGMxOWdjSURSOGJCd1FIRWdnQ1dpNkRJZ0x1QVFZQStCQUZDaGEzQTVYaUFFc3FNN1VGRmdGTGhBTWpGVE1ZRTFLbG53NzRuUlZCRy9BU0NtMEJZUk4vQnJzVTNWb1d5K1MwdlY4TFF4K3ZOOGdGMkFDMkFLNUVBV3dBcGdZREttQUFyb1EwTkRRMEFUK09DZzd3QUFJSFJBYnBOZ1ZjQlYwQVBUQTVCZmJQRmdNTHpjWUwvUXFxQTgyZUJBTEtDalFDanFZQ2h0MC9rMitPQXNYUUFvUDNBU1RLRGdEdzZBQ0tBVVlDTXBJS0pwUmFBRTRBNXdvbUFCelp2czBSRUVLaUFDSVFBZDVRZEFFQ0FqNFl3Zy93R3FZMkFWZ0FZQURZdkFvQ0dBRXViQTBndkFZMkFMQUFicGJ2cXB5RUFHQUVwZ1FBSmdBRzdnQWdBRUFDbWdoVUZ3Q3FBTXBBSU5RSXdDNER0aFJBQVBjeWNLZ0Fwb0lkQUJ3QmZDaXNBQm9BVHdCcUFTSUF2aG5TQlA4YUgvRUNlQUtYQXE0ME5qZ0RCVHdGWVFVNkFYczNvQUJnQUQ0WE5nbWNDWTFlQ2w1dElGWmVVcUdneW9OSEFCZ0FFUUFhQUJOd1dRQW1BQk1BVFBNYTNUMzRBRGxkeXBybU0xTTJYb2NpVVFnTHp2d0FYVDN4QUJnQUVRQWFBQk53SUdGQW5BREQ4QUFnQUQ0QkJKV3phQ2NJQUlFQkZNQVd3S29BQWRxOUJXQUY1d0xRcEFMRXRRQUtVU0drYWhSNEduSk0rZ3NBd0NnZUZBaVVBRUNRMEJRdUw4QUFJQUFBQURLZUloZWNsdkZxUUFBRVRyNGlBTXhJQVJNZ0FNSW9IaFFJQW4wRTBwRFFGQzRIaHpub0FBQUFJQUkyQzAvNGx2RnFRQUFFVGdCSkp3WUNBeTRBQmdZQUZBQThNQktZRUg0ZVJoVGtBalllRmNnQUNBWUFlQUJzT3F5UTVnUndEYXlxdWdFZ2FJSUF0Z29BQ2dEbUVBQm1CQVdHbWU1T0JKSkEybTRjRGVvQW1JVFdBWHdyTWdPZ0FHd0JDaDZDQlhZRjFUemcxd0tBQUZkaXVBQlJBRndBWFFCc0FHOEFkZ0JyQUhZQWJ3Q0VBSEV3ZnhRQlZFNVRFUUFEVkZoVEJ3QkRBTklMQXFjQ3pnTFRBcFFDclFMNnZBQU1BTDhBUExoTkJLa0U2Z2xHS1RBVTREcjROMkVZRXdCQ2tBQktrOHJIQWJZQm13SW9BaVU0QWpmL0FxNENvd0NBQU5JQ2h6Z2FOQnNDc1RnZU9EY0ZYcmdDbFFLZEFxUUJpUUdZQXFzQ3NqVHNOSHNmTlBBMGl4c0FXVFdpT0FNRlBEUVNOQ2syQkRaSE5vdzJUVFpVTmhrMjhKazlWekkzUWtFb0FvSUNvUUt3QXFjQVFBQXhCVjRGWGJTOUJXNDdZa0lYUDFjaVVxczA1RFMvRndBQlV3SlcxMWU2bkh1WVptU2gvUkFZQThvTUt2WjhLQVNvVUFKWVdBSjZJTEFzQVpTb3FqcGdBMG9jQklobURnRFdBQWF3UkRRb0FBY3VBajVpQUhBQlppUjJBSWdpSGdDYUFVNjhBQ3h1SEFHMHlnTThNaVpJQWxnQmRGNEdhZ0pxQVBaT0hBTXVCZ29BVGtZQXNBQmlBSGdBTUxvR0RQajBIcEtFQkFBT0pnQXVBTGdnVEFIV0FlQU1FRGJkMjBVZWdlMEFEd0FXQURrQVFnQTlPSGQrMk1VUVpCQmhCZ05ORGt4eFB4VVFBckVQcXd2cUVSb00xaXJRMDkwQU5LNEg4QU5ZQi9BRFdBTllCL0FIOEFOWUIvQURXQU5ZQTFnRFdCd1A4Qi9ZeFJCa0QwMEVjZ1dUQlpBRTJ3aUlKazRSaGdjdENOZFVFblFqSEV3RFNnRUJJeXBKSVR1WU14QWxSMHdSVFFnSUFUWkhiS3g5UFFOTU1iQlUrcENuQTlBeVZEbHhCZ01lZGhLbEFDOFBlQ0UxdWs2RGVreHhwUXBRVDdOWDl3QkZCZ0FTcXdBUzVnQkpEU2dBVUN3R1BRQkk0elRZQUJOR0FFMmJBRTNLQUV4ZEdBQkthQWJnQUZCWEFGQ09BRkJKQUJJMlNXZE9iQUxET3EwLy9Rb21DWmh2d0hkVEJrSVFIQ2VtRVBnTU5BRzJBVHdON2t2WkJQSUdQQVRLSDM0WkdnL09sWjBJcGkzZURPNG01QzZpZ0ZzajlpcUVCZTVMOVR6ZUMwNVJhUTlhQzJZSjVEcGtnVThESWdFT0lvd0szZzA2Q0c0UTlBcktiQTNtRVVZSE9nUFdTWnNBcGdjQ0N4SWROaFcySmhGaXJRc0tPWGdHL0JyM0M1QW1zQk1xZXYwRjFCb2lCazRCS2hzQUFOQXU2SVd4V2pKY0hVOWdCZ1FMSmlQSUZLbFFJUTBtUUxoNFNSb2NCeFlscWdLU1EzRktpRkUzSHBRaDl6dytEV2N1RkZGOUIvWThCaGxRQzRJOG4wYXNSUThSMHo2T1BVa2lTa3d0QkRhQUxEQW5qQW5RRDRZTXVueHpBVm9KSWdteURISVRNaEVZTjhZSU9nY2FMcGNsSnhZSUlrYVdZSnNFK0tBRDlCUFNBd3dGUUFsQ0J4UUR0aHd1RXk4VktnVU9nU1hZQXZRMjFpNjBBcEJXZ1FFWUJjd1BKaC9nRUZGSDRRN3FDSndDWmdPRUpld0FMaFVpQUJnaW5BaEVaQUJnajlsVEJpN01DTWhxYlNOMUEyZ1U2R0lSZEFlU0RsZ0hxQncwRmNBYzRuREpYZ3lHQ1Npa3NBbGNBWFlKbWdGZ0JPUUlDalZjaktFZ1FtZFVpMWtZbkNCaVFVQmQvUUl5REdZVm9FUytoM2tDakE5c0Vod0JOZ0YwQnpvTkFnSjRFZTRSYkJDV0NPeUdCVFcyTS9rNkpnUlFJWVFnRWdvb0ExQnN6d3NvSnZvTStXb0JwQkpqQXcwMFBuZnZaNnhndHlVWC9nY2FNc1pCWVNIeUM1TlB6Z3lkR3NJWVExUXZHZVVId0FQMEd2UW42MEZZQmdBRHBBUVVPazR6N3dTK0Myb0lqQWxBQUVvT3BCZ0gyQmhyQ25LTTBRRXlqQUc0bWdOWWtvUUNjSkFHT0FjTUFHZ01pQVY2NWdBZUFxZ0lwQUFHQU5BRFdBQTZBcTRIbmdBYUFJWkNBVDRES0RBQkl1WUNrQU9VQ0RMTUFaWXdBZlFxQkJ6RURCWUErRGh1U3dMRHNnS0FhMmFqQmQ1WkFvOENTallCVGlZRUJrOUlVZ093Y3VJQTNBQk1CaFRnU0FFV3JFdk1HK1JFQWVCd0xBRElBUHdBQmpZSEJrSUJ6Z0gwYmdDNEFXQUxNZ21qdExZQlR1b3FBSVFBRm13QjJBS0tBTjRBTmdDQThnRlVBRTRGV3ZvRjFBSlFTZ0VTTWhrc1dHSUJ2QU1nQVRRQkRnQjZCc3lPcHNvSUlBUnVCOVFDRUJ3VjRnTHZMd2UyQWdNaTRCUE9Rc1lDdmQ5V0FESVhVdTVlWndxb0NxZGVhQUMwWVRRSE1uTTlVUUFQSDZrK3lBZHkvQlpJaVFJbVN3QlE1Z0JRUXpTYU5URldTVFlCcHdHcUtRSzM4QUZ0cXdCSS93SzM3Z0szclFLM3NBSzYyODBDMGdLMzNBSzN6eEFBVUVJQVVEOVNrbEtEQXJla0FydzVBRVFBekFIQ08xNDdXVHRlTzFrN1hqdFpPMTQ3V1R0ZU8xa0RtQ2hZSTAzQVZVMG9KcWtLYlY5R1lld01wdzNWUk1rNlNoUGNZRkpnTXhQSkxiZ1V3aFhQSlZjWlBocTlKd1lsNVZVS0R3VXQxR1l4Q0MwMGRoZTlBRUFwYVlOQ1k0Y2VNUXBNSE9oVGtsVDVMUndBc2t1ak03QU5yUnNXUkVFRlNIWHVZaXNXRHdvakFtU0NBbUpEWEU2d1hEY2hBcUg0QW1pWkFtWUtBcCtGT0J3TUFtWThBbVluQkc4RWdBTi9GQU4ra3prSE9YZ1lPWU02SkNRQ2JCNENNamM0Q3dKdHlBSnRyL0NMQURSb1Jpd0JhQURmQU9JQVN3WUhtUXlPQVA4TXd3QU90Z0ozTUFKMm8wQUNlVXhFQW5pN0hsM2NSYTlHOUFKOFFBSjZ5UUo5Q2dKODhVZ0JTSDVrSlFBc0ZrbFpTbHdXR0VyTkF0RUNBdEROU3lnRGlGQURoK2RFeHBFekF2S2lYUVFEQTY5THowd3VKZ1RRVFUxTnNBS0xRQUtLMmNJY0NCNUVhQWE0QW80NEFvNWRRWmlDQW83YUFvNWRlVkcxVXpZTFV0VlVoZ0tUL0FLVERRRHFBQjFWSDFXd1ZkRUhMQndwbG9jeTRuaG5SVHc2QXBlZ0F1K3pXQ0twQUZvbUFwYVFBcFo5blFDcVdhMWFDb0pPQUR3Q2xyWUNsazljUlZ6U0Fwbk1BcGxsWE10ZENCb0NuSnc1d3pxZUFwd1hBcCtjQXA2NWl3QWVFRElyRUFLZDhnS2Vrd0MyUG1FMVlmQUNudFFDb0c4QnFnS2VvQ0FDbmsrbVk4bGtLQ1lzQWlld0FpWi9BcUQ4QXFCTjJBS21NQUtsendLb0FBQitBcWZ6YUgxb3NnQUVTbW9kYXRJQ3JPUUNySzhDcldnQ3JRTUNWeDRDVmQwQ3NlTFlBeDlQYkpnQ3NyNE9BckxwR0d6aGJXUnRTV0FESmM0Q3RsMDhRRzZSQXlsR0FyaGZBcmxJRmdLNUszaHdOM0RpQXIwYUF5MnpBeklTQXI2SmNnTURNM0lDdmh0ekkzTlFBc1BNQXNNRmM0TjBURFpHZE9FRFBLZ0RQSnNEUGNBQ3hYMEN4a2dDeGhHS0FzaHFVZ0xJUlFMSlVBTEpMd0prbmdMZDAzaDZZbml2ZVNaTDBRTVlwR2NEQW1IMUdmU1ZKWHNNWHBOZXZCSUN6MndDejIwd1RGVFQ5QlNnQU1ldUFzOTBBU3JyQTA0VGZrd0dBdHdvQXR1TEF0SlFBMUpkQTFOZ0FRSURWWTJBaWtBQnpCZnVZVVoyQUlMUGc0NEMyc2dDMmQrRUVZUktwejBEaHFZQU1BTmtENFp5V3ZvQVZnTGZaZ0xldVhSNEF1SXc3UlVCOHpFb0FmU2NBZkxUaUFMcjlBTHBjWG9BQXVyNkF1cmxBUHBJQWJvQzdvb0M2NTJXcTVjRUF1NUFBNFhobUhwdzRYR2lBdk1FQUdvRGpoZVpsQUwzRkFPUmJ3T1NpQUwzbVFMNTJnTDRaNW9kbXF5OE9Kc2ZBNTJFQXY3N0FSd0FPcDhkbjdRREJZNERwbXNEcHRvQTBzWURCbXVoaWFJR0NnTU1TZ0ZnQVNBQ3RnTkdBSndFZ0xwb0JnQzhCR3pBRW93Y2dnQ0VEQzZrZGpvQUpBTTBDNUlLUm9BQlpDZ2lBSXp3M0FZQkxBQ2tmbmc5b2dpZ2tnTm1XQU42QUVRQ3Zya0VWcVRHQXdDc0JSYkFBKzRpUWtNQ0hSMDcyakkyUFRiVU5zazJSalk1TnZBMjNUWktOaVUzRURjWk41SStSVHhEUlRCQ0prSzVWQllLRmhaZndRQ1d5Z1UzQUpCUkhwdStPeXRnTnhhNjFBNDBHTXNZanNuN0JWd0ZYUVZjQlYwRmFBVmRCVndGWFFWY0JWMEZYQVZkQlZ3RlhVc2FDTnlLQUs0QUFRVUhCd0tVN29JQ29XMWU3akFFemdQeEErWUR3Z0NrQkZEQXdBREFCS3pBQU94RkxoaXRBMVVGVERleVBrTStiajUxUWtSQ3V3VFFXV1E4WCswQVdCWXpzQUNOQTh4d3pBR203RVovUWlzb0NUQWJMRHM2Zm5MZmI4SDJHY2NzYmdGdzEzTTFIQVZrQlcvSnhzbTlDTlJPOEU4RkREMEZCUXc5RmtjQ2xPWUNvTUZlZ3BEZkFEZ2NNaUEyQUpRQUNCOEFzaWdLQUl6SUVBSktlQklBcFk1eVBaUUlBS1FpSGI0ZnZqNUJLU1JQUXJaQ096MG9YeXhnT3l3ZktBbkdiZ01DbFFhQ0FrSUxYZ2RlQ0Q5SUlHVWdRajVmUG9ZK2RUNTJBbzVDTTBkQVg5QlRWRzlTRHpGd1dUUUFieEJ6SkYvbE9FSVFRZ2xDQ2tLSklBbHM1QWNDbFFJQ29LUE1PREVGeGhpNktTQWJpeWZJUnJNanRDZ2RXQ0FrUGxGQklpdENzRUpSekFiTUFWL09FeVF6RGcwT0FRUUVKMzZpMzI4L01rOUF5YkRKc1FscTN0RFJBcFVLQWtGelhmMWQvajl1QUxZUDZoQ29GZ0NUR0Q4a1BzRktRaW9icm0wK3pqMEtTRDhrUG5WQ1JCd01EeUpSVEhGZ01USmE1cndYUWlRMllmSS9KRDdCTUVKRUhHSU5UdzRUT0ZsSVJ6d0pPMGljTVFweVB5USt3ekpDUkJ2NkRWZ25LQjAxTmdVS2oyYndZek1xQ29Ca3puQmdFRit6WURJb2N3UklYK05nSGo0SElDTmZoMkM0Q3dkd0ZXcFRHL2xnVWhZR0F3UmZ2MlRzOG1BYVh6VmdtbC9YWUlKZnVXQzRISTFnVUY5cFlKWmdNUjZpbFFITUFPd0xBbERSZWZDMGluNEFYQUVKQTZQakN3YzBJYW1PQU5NTUNBRUNSUURGTlJUWkJnZCtDd1FsUkErcjYrZ0xCREVGQm53VUJYZ0tBVElBcndBR1JBQUhBM2NEZEFOMkEza0Rkd045QTNvRGRRTjdBMzBEZkFONEEzb0RmUUFZRUFBbEF0WUFTd01BVUFGc0FIY0tBSGNBbWdCM0FIVUFkUUIyQUhWdThVZ0F5Z0RBQUhjQWRRQjFBSFlBZFFBTENnQjNBQXNBbWdCM0FBc0NPd0IzQUF0dThVZ0F5Z0RBQUhnS0FKb0Fkd0IzQUhVQWRRQjJBSFVBZUFCMUFIVUFkZ0IxYnZGSUFNb0F3QUFMQ2dDYUFIY0FDd0IzQUFzQ093QjNBQXR1OFVnQXlnREFBSDRBQ3dHZ0FMY0Jwd0M2QWFoZEF1MENPd0x0YnZGSUFNb0F3QUFMQ2dDYUF1MEFDd0x0QUFzQ093THRBQXR1OFVnQXlnREFBMjRBQ3dOdkFBdTBWc1FBQXpzQUFCQ2tqVUlwQUFzQVVJdXNPZ2dXY2dNZUJ4VnNHd0w2N1UvMkhsem1XT0VlT2dBTEFTdnVBQXNlQWZwS1VwbnBHZ1lKRENJWk02WXlBUlVFOVRocUFENWlYUWduQUpZSlBuT3p3MFpBRVp4RUtzSUFrQTREaEFIblRBSUR4eFVESzBseENRbFBZZ0l2SVFWWUpRQlZxRTFHYWtVQUtHWWlEVG9TQkExRXRBWUFYUUpZQUlGOEdnTUhSeUFBSUFqT2U5WW5jZWtSQUEwS0FDVXJqd0U3QXljNkFBWVdBcWFpS0c0TWNFY3FBTm9OMytNZzlUd0NCaElrdUNueStKd1VRMjlMMDA4Smx1Unh1M0srb0FkcWlIT3FGSDBBRzVTVUlmVUo1U3hDR2Z4ZGlwUnpxVG1UNFY1WmIrcjFVbzRWbStOcVNTRWwybU52UjJKaElhOFNwWU82bnRkd0ZYSENXVENLOGYyK0h4bzd1aUczZHJEeWNBdUtJTVA1YmhpMDZBQ25xQXJIMXJ6NFJxZy8vbG02U2dKR0VWYkY5eEpISVNhUjZIeHF4U25rdzZzaERuZWxIS05FZkdVWFNKUkoxR2NzbXRKdzI1eHJaTURLOWdYU20xL1lNa2RYNC82TktZT2R0ay9OUTMvTm5EQVNqVGMzZlBqSWpXLzVzVmZWT2JYMm9URFdrcjFkRjlmM2t4QnNEMy8zYVFPOGhQZlJ6K2UwdUVpSnF0MTE2MWdyaXU3Z3o4aEREd3RweStGK0JXdGVmbktIWlBBeGNab1dibnpuaEpweTBlODQyajM2YmNOekduSUV1c2dHWDBhOFp4c25qY1NzUERaMDl5WjM2ZkNRYnJpSGVRNzJKUk1JTE5sNmVQUGYySFdvVndnV0FtMWZiM1Yyc0FZMCtCNnJBWHFTd1BCZ3NlVm1vcXNCVFNybTkxK1hhc01ZWXlTSThlZVJ4SDNadkhrTXozQlE1YUozaVVWYllQTk0zLzdlbVJ0amxzTWd2LzlWeVRzeXQvbUsrOGZnV2VUNlNvRmFjbFhxbjQyZEFJc3ZBYXJGNXZOTldIektTa0tRLzhIZms1WldLN3I5eWxpT3Nvb3lCalJoZmtIUDRRMkRrV1hRaTZGRy85ci9Jd2Jta1Y1VDdKU29wSEtuMXBKd205dGI1T3Qwb3lOMVoybVBwS1hIVHh4Mm5sSzA4ZktrMWhFWUE4V2dWVldMNWxneDBpVHYrS2RvakplVTIzWkRqbWl1YlhPeFZYSktLaTJXanVoMkhMWk9GTGlTQzdUbHM1U01oNGYrUGo2eFVTck5qRnFMR2VoUk5COGxDMFFTTE5ta0pKeC93U0czTW5qRTlUMUNrUHdKSTB3SDJsZnp3RVRJaVZxVXhnMGRmdTVxMzlHdCtod2RjeGtoaE52UTRUeXJCY2VvZjNNaHMvSXhGY2kxSG1IcjRGTVpnWEVFY3pQaUdDeDBIUnd6QXFEcTJqOUFWbTFrd04wbVJWTFdMeWxndG9QTmFwRjVjWTRZMXdKaC9lMEJCd1pqNDRZZ1pyRE5xdkQvOUh2N0dGWWRVUWVESnVRM0VXSTRIYUtxYXZVMVhqQy9uNDFrVDRMNzlrcUdxMGtMaGRUWnZnUDNUQTNmUzBvelZ6KzVwaVpzb090SXZCVUZvTUtiTmNtQkw2WXh4YVVBdXNIQjM4WHJTOGRRTW5Rd0pmVVVrcFJvR3I1QVVlV2ljdkJUenlLOWc3Nyt5Q2tmNVBBeXNMN3IvSmpjWmdyYnZScE1XOWl5YXhadktPNmNlWk4yRXdJeEt3VkZQdXZGdWlFUEdDb2FnYk1vK1NweWRMclhxQnpOQ0RHRkNyTy9ya2N3YTJ4aG9rUVo1Q2RaMEFzVTNKZlNxSjZuNUkxNFlBK1AvdUFnZmhQVTg0VGx3N2NFRmZwN0FFRThleTRzUDEyUFR0NENvZHMxR1JnRE9CNXh2eWlSNW0rQng4TzVuQkNOY3RVOEJldmZWNUEwOHg2UkhkNWpjd1BUTURTWkpPZWRJWjFjR1E3MDRseGJBenFaT1AwNVp4YU9naHpTZHZGQkhZcW9tQVRBUnlBQURLNGVsUDhMeTNJclVaS2ZXaDIzWHkyMHVCVW1MUzRQZmFndTkrb3lWYTJpUGdxUlAzRjJDVFVzdko3K1JZbk44ZkZaYlUvSFZ2eHZjRkZES2tpVHFWNVVCWjNHejU0SkFLQnlpOWhrS01aSnZ1R2djU1lYRm13MDhVeW9ReVZkZlREMS9kTWtDSFhjVEdBS2VST2dBcnN2bVJyUVRMVU9YaW9PSEdLMlFrakh1b1lGZ1hjaVpvVEpkNkZzNXExUVgxRytwL2UyNmhZc0VmN1FaRDFubkl5bC9TRmtOdFlZbW1CaHBCcnhsOVdiWTBZcEhXUnV3MkxsL3RqOW1EOFA0c25WekpsNEY5SisxYXJWZVRiOUU1cjJJTEgwNHFTdGp4UU53bjNtNFlOcXhtYU5iTEFxVzJUTjZMaWR3dUpScVMrTlhidHF4b2VEWHB4ZUdXbXh6U2tXeGpreUNrWDROUVJtZTZxNVNBY0MrTTcrOUVUZkEvRXdyelFhaktha0N3WXlldW5QNlpGbHhVMm9NRW4xUHozMXplU3RXNzRHNDA2WkpGQ2wxd0FYSW9VS2tXb3RZRXBPdVhCMXVWTnhKNjNkcEpFcWZ4QmVwdHdJSE5yUHo4QmxsWm9JY0JvWHdnZkorOFZBVW5WUHZSdmV4bncwTWEvV2lHWXVKTzV5OFFUdkVZQmlnRm1oVXhZNVJxekU4T2N5d04vOG00VVlybGFuaUpPNzVYUTZLU285K3RXSGx1K2hNaTBVVmRpS1FwN05lbG5vWlV6TmFJeUJQVmVPd0s2R05wK0ZmSHVQT295aGFXdU52VFlGa3Z4c2NNUVdEaCt6ZUZDRmtnd2JYZnRpVjIzeXdKNCt1d1JxbWc5azNLendJUXB6cHB0OERCQk9NYnJxd1FNNUdiMDVzRXdkS3pNaUFxT2xvYUEvbHIwS0ErMXByMC8rSGlXb2lJakhBL3dpcjJuSXVTM1BlVS9qaTNPNlp3b3hjUjFTWjlGaHRMQzVTMEZJekZoYkJXY0dWUC9LcHhPUFNpVW9BZFdVcHFLSCsrNlNjejUwN2lDY3hZSTZyZE1CSUNQSlplYTdPY21lRnc1bU9iSlNpcXBqZzJVb1dOSXMrY0ZoeURTdDZnZVY1cWdpM0Z1bm13d0RvR1NNZ2VyRk9aR1gxbTBkTUNZbzVYT3J1eE8wNjNkd0VOSzlEYm5WTTl3WUZSRXpoNHZ5VTFXWVlKL0xSUnA2b3hnanFQL1g1YTgvNEFmNnA2TldrUWZlcnpCbVhtZTB6WS80bndNSm0vd2QxdElxU3dHeitFM3hQRUFPb1psSml0M1hkZEQ3L0JUMXBsbHpPeCs4Ym1RdEFOUS9TNmZaZXhjNnFpM1crUTJ4Y21YVFVodVM1bXBIUVJ2Y3haVU4wUzUrUEw5bFhXVUFhUlpoRUg4aFRkQWN1Tk1NQ3VWTktURUd0U1VLTmkzTzZLaFNhVHpjazhjc1oydldSWitkN21XOGM0SUt3WElZZDI1Uy96SWZ0UGt3UHp1ZmpFdk9IV1ZEMW0rRmpwRFZVVFYwREdEdUhqNlFuYUV3THUvZEVnZExRT2c5RTFTcm85WEhKOHlrTEF3dFB1K3B4cUtEdUZleHFPTjFzS1FtN3J3YkUxRTY4VUNmQS9lcm92clRDRytEQlNOZzBsNGdvRFF2Wk42dU5sYnlMcGNaQXdqMlVjbHljdkxwSVpNZ3Y0eVJscGIzWXVNZnRvem9yYmNHVkh0L1ZlRFYzK0ZkZjFUUDBpdWFDc1BpMkc0WGVHaHN5RjF1YlZEeGtvSmhtbmlRMC9qU2cvZVlNTDlLTGZuQ0ZnSVNXa3A5MWVhdVIzSVF2RUQwbkFQWEsrNmhQQ1lzK24zK2hDWmJpc2ttVk1HMmRhKzBFc1pQb25VZUlZOEViZnVzUVhqc0svZUZEYW9zYlBqRWZRUzBSS0c3eWo1R0c2OU03TWVPMUhtaVVZb2NneWdKSEw2TTFxelVERHdVU21yOTlWN1NkcjJGM0pqUUFKWStGMHlIMzNJdjMrQzlNMzhlTUw3Z1RnbU51L3IyYlVNaVB2cFliWjZ2MS9JYUVTaXJCSE5hN21QS240ZEVtWWc3di8rSFFnUE4xRzc5akJRMStzb3lkZkRDMnIraDJCbC9LSWM1S2pNSzdPSDZuYjFqTHNOZjBFSFZlMktCaUU1MW94NjM2dXlHNkxobzB0M0ozNEw1UVkvaWxFM21pa2FGNEhLWEcxbUcxckNldlQxVnY2R2F2bHR4b1FlL2JNcnBadlJnZ25CeFNFUEVlRXprRWRPeFRuUFhIVmpVWWR3OEpZdmpCL283RWVnYzNNYStOVXhMTG5zSzBrSmxpblBtVUh6SEd0cms1K0NBYlZ6Rk9CcXB5eTNRVlVuelREZkMvMFhEOTQvb2tIK09CK2k3Zzlsb2xoV0lqU25mSWIrRXE0M1pYT1dtd3ZqeVYvcXFEK3QwZSs3bVRFTTc0cVAvT3p0OG5tQzdtUnB5dTYzT0I0S25VekZjMDc0U3FveVBVQWdNKy9USkdGbzZUNDRFSG5RVTRYNHo2cWFublZxZ3cvVTd6Q3B3Y21YVjFBdWJJcnZPbWtLSGF6SkFSNTVlUGpwNXRMQnNOOHZBcXMzTkFIZGNFSE9SMnhRMGxzTkFGelNVdXhGUUNGWXZYTFpKZE9qOXA0Zk5xNnAwSEJHVWlrMll6YUk0eHlTeTkxS3poUTArcTFoanh2SW1Sd1BSZjc2dENobFJraFJDaTc0TlhaOXFVTmVJd1ArczVwKzNtNW53UGROT0hnU0xENzluN085bTFuMXVESGlNbnRxNG5rWXdWNU9aMUVOYlh4RmQ0UGdybHZhdlpzeVVPNE1xWWxxcW4xTzhXL0kxZEVacTVkWGhyYkVUTGFaSWJDMktqL0FhL1FNK2ZxVU9IZGYwdFhBUTFodVozY21XRUNXU1h5LzQzajM1K012cTl4d3M3SktzZXJpWjFwRVdLYzhxbHpOckdQVUdjVmdPYTljUEpZSUpzR25KVEFVc0VjRE9FVlVMTzV4MHJYQmlqYzFsZ1hFelFRS2hST2Y4eklWODJ3OGVzd2M3OFlYMTFLWUxXUVJjZ0hOSkVsQnhmWHI3MmxTMlJCU2wwN3FUS29yTzJ1VURacjNzRmhZc3ZuaExabjBBOTRLUnpKLzdERUdJQWhXNVpXRnBMOGdFd3UxYUxBOU11V1p6TndsOE96ZTlZK2JYK3Y5Z3l3UlZub0I1SS84a1hUWFUzMTQxeVJMWXJJT096NlNPbnlITnk0U2llcXprQlhoYXJqZmpxcTFxNnRrbGFFYkE4UWZtMkRhSVBzN09UcS9udkpCaktmTzJIOWJIMmNDTWgxKzVnc3BmeWN1OGYvY3V1Um10RGp5cVo3dUNJTXlqZFYzYStwM2ZxbVhzUng0QzhsdWpleklGSG5RaVZUWExYdUkxWHJ3TjMrc2lZWWoySEhUdkVTVXg4RGxPVFhwYWs5cUZSSytMM21nSjFXc0Q3RjRjdTFhSm9Gb1lRbnUrd0dETU9qSk0za2lCUVdIQ2N2aEovSFJkeG9kT1FwNDVZWmFPVEEyMk5iNFhLQ1Z4cWtid01ZRmh6WVFZSUFuQ1c4RlcxNHVmOThqaFVHMnpyS2hRUTBxMENFcTB0NW5YeXZVeXZSOER2RDY5TFUrZzNpK0hGV1FNUThQcVp1SEQrc05LQVYwK002RUpDMHN6cTdyRXI3QjViUThCY05IenZETWM5ZXFCNVpDUWRUZjgwT2JuNHV6andwWVU3U0lTZHRWMFFHYTlEM1dyaDJCRFF0cEJLeGFORlYrL0N5MlAvU3YrOHM3VWQwRmQ3NFg0K28vVE56dFdnRVRVYXB5K21hak5RNjhMcTNlZTBaTzQ4VkViVFpZaUgxQ280T2xmV2VmODJSV2V5VVhvN3dvTTAzUHlhcEdmaWtUblFpbm9OcTV6NXZlTHBlTVYzSENBTVRhWm1BMW9HTEFuN1hTM1hZc3orWEs3Vk1Rc2M0WEtybURYT0xVL3BTWFZOVXE4ZElxVGJhLy8vM3g2TGlMUzZ4czF4dUNBWVNmY1EzK3JRZ211N3V2ZjNUSEt0NU9vbzk3VHFjYlJxeHg3RUFTaXphUUNCUWxsRy9yWXhWYXBNTGd0TGJaUzY0dzFNREJNWFgrUFFwQktOd3FVS09mMkREUkRVWFFmOUVoT1MwUWo0blRtbEE4ZHpTTHovRzFkK1VkOE1UeS82Z2hoZGlMcGVlckdZL1VsRE9maXVxRnNNVVU1L1VZbFArQkFtZ1JMdU5wdnJVYUxsVmtycURpZXZOVkVBd0YrNENvTTFNWlRtanhqSk1zS0pxK3U4WmQ3dE5DVUZ5NkxpeVlYUkpRNFZ5dkVRRkZhQ0dLc3hJd1FrazdFelo2TFRKcTJoVXVQaHZBVytnUW5TRzZKK01zekMrN1FDUkhjbnFEZHlOUko2VDl4eVM4N0E2TUR1dGJ6S0d2R2t0cGJYcXR6V3RYYjlIc2ZLMmNCTW9tak45YTR5K1RhSkxuWHhBZVgvSFd6bWY0Y1I0dkFMdC9QNHc0cWdLWTA0bWw0WmRMT2luRllTNmN1cDNHLzFpZTQrdDFlT25wQk5scUdxczc1aWx6a1Q0K0RzWlF4TnZhU0tKLy82ekliYmsvTTdMT2hGbVJjLzFSK2tCdHo3SkZHZFptL0NPb3RJZHZRb1hwVHFQLzF1cUVVbUNiL1FXb0dMTXdPNUFOY0h6eGRZNDhJR1A1K0orektPVEJGWjRQaWQrR1RNK1dxMTJNVi9IODZ4RUpwdEJhNlQrcDNrZ3B3TGVkTWFuQkhDMkdnTnJGcG9OMnhuck16OVdGV1gvOC95Z1NCa2F2cTJVdjdGZENzTEVZTHU5TExJdkFVMGJOUkR0ellsKy92WG1qcEl2dUpGWWptSTBpbTZRRVlxbkllTXNOalhHNHZJdXRJR0hpamVBRy85RURCb3pLVjVjbGRrSGJMeEhoMjV2VCtaRXpiaFhscXZwektKd2NFZ2ZOd0xBS0ZlbzAvcHZFRTEwWERCK0VYUlRYdFN6Sm96UUtGRkFKaE14WWtWYUNXK0U5QUw3dE1lVThhY3hpZEhxemI2bFg0NjkxVXNEcHkvTExSbVQrZXBnVzU2KzVDdzh0QjRrTVV2NnM5bGgzZVJLYnlHcytILzRtUU1hWXpQVGYyT09kb2tFbit6emd2b0QzRnFOS2s4UXFHQVhWc3FjR2RYclQ2MmZTUGtSMnZST0ZpNjhBNnNlODZVeFJVazRjYWpmUHlDQzRHNXdEaEQrek5xNGpvZFE0dTRuL20zN0xyMzZuNExJQUFzVnIwMmRGaTlBaXdBODFNWXMycm00ZURsRE5tZE1SdkVLUkhmQndXNURkTU5wMGpQRlpNZUFScUYvd0w0WEJmZCtFTUxCZk16cEg1R0g2TmFXKzF2cnZNZGcrVnhEemF0azNNWGdPM3JvM1AvRHBjQzYrTW80TXlTSmhLSmhTUjAxU0dHR3A1aFBXbXJyVWdydjNsRG5QK0hoY0kzbnQzWXFCb1ZBVlRCQVFUNWl1aFRnOG52UHRkOFplWWo2dzF4NlJxR1VCclNrdTcrTjErQmFhc1p2alRrNjRSb0lEbEw4YnJwRWNKeDNPbVk3akxvWnNzd2R0bWhmQy9HMjFsbFhoSVRPd212UkREZVRUUGJ5QVNPYTE2Y0Y1L0ExZlpBaWRKcHFqdTN3WUF5OWF2UFIxeWE2ZU5wOUs4WFlycnR1eGxxaStiREt3bGZyWWRSMFJSaUtSVlRMT0g4NStaWTdYU216UnBmWkJKamFUYTgxVkRjSkhwWm5ablNRTEFTR1lXOWw1MVpWL2g3ZVZ6VGkzSHY2aFVzZ2MvNTFBcUpSVGtwYkZWTFhYc3pvQkw4bkJYMHUvMGpCTFQ4bkgrZkplUGJyd1VSVDU4T1krVWllUmpkMXZzMDR3MFZHNVZOMlU2TW9HWmtRektOL3B0ejBRMzY2ZHhvVEdtajdpMU5RR0hpOUdnbnF1WEZZZHJDZlpCbWViN3MwVDZ5cmRsWkg1Y1p1d0hGeUlKL2tBdEdzVGcweEg1dGFBQXE0NEJBazFDUGs5S1ZWYnFRenJDVWlGZEYvNmd0bFBROGJISGMxRzFXOTJNWEdaNUhFSGZ0eUxZczhtYkQvOXhZUlVXa0htbE0wekMyaWxKbG5OZ1Y0YmZBTHBRZ2h4T1VvWkw3VlRxdENISWFRU1htK1lVTW5wa1h5Ym5WK0E2eGxtMkNWeThmbjBYbG0yWFJhMCt6ek9hMjFKV1dtaXhmaVBNU0NaN3FBNHJTOTNWTjNwa3BGMXM1VG9uUWppc0hmN2lVOVpHdlVQT0FLWmNSMXBiZVZmL1VsN09oZXBHQ2FJZDl3T3RxbzdwSjd5TGNCWjBwRmtPRjI4eTR6RUkva2NVTm11dEJIYVFwQmROTTh2akNTNkhaUm9ra2VvODhUQkFqR3lHN1NSKzZ2VWdUY3lLOUltYWxqMGt1eHowd21LK2J5UVUxMUFpSkZrL3lhNWROZHVSQ2xjblU2NHlHdS9pZVdTZU9vczF0M2VwK1JQSVdRMnB5VFlWYlpsdFRic2I3Tml3U2kzQVYrOEtMV2s3THhDbmZaVWV0RU04VGhuc1NvR0gzOC9ueUF3Rmd1SnA4Rmp2bEh0Y1dadVU0aFB2YTBySGZyMFVoT09KL0Y2dlM2MkZXN0t6a21SbGwySEVjN29VcTRmeWk1VDcwVmw3WVZJZnNQSFVDZEhlc2Y5TGs3V05WV083NUpEa1liTUk4VE9XOEpLVnRMWTlkNlVKUklUTzhvS28weFMrbzk5WXkwNGluaUdIQWFHajg4a0VXZ3d2ME9ySGRZL25yNzZET0dOUzU5aFhDR1h6VEtVdkRsOWlLcExTV1lOMWx4SWV5eXdkTnBUa2hheTc0dzJqRlQ2TlM4cWtqbzVDeEExeWZTWXdwNkFKSVpOS0llRUs1UEpBVzdPUmdXZ3dwMFZnellwcW92TXJXeGJ1K0RHWjZMaGllMVJBcXB6bThWVXpLSk9IM21Deld1VE9Mc04zVlQvZHYyZWVZZTlVamJSOFlUQnNMejdxNjBWTjFzVTUxayt1bTFmOEp4RDVwUGhiaFNDOHJSYUI0NTR0bWg2WVVXckpJMytHV1kwcWVXaW9qL3Ria1lJVE9rSmFldUd0NEpySnZIQStsMEd1N2tZN1hPYWEwNWFsTW5SV1ZDWHFGZ0xJd1NZNHVGNTlVZTVTVTRRS3VjL0hhbUR4YnIweDZjc0NldFhHb1A3UW4xQmsvSjlEc3luTy9VRDZpWjFIeXJ6K2ppdDBoREN3aS9FOU9qZ0tUYkIzWlFLUS8wWk92ZXZmTkhHME5LNEFqM0NwN05wUmswN1JUMWkvUzBFTDkzQWc4R1JnS0k5Q2ZwYWpLeUs2K0pqL1BJMUtPNS84NVZBd3oyQXd6UDhGVEJiMDc1SXhDWHY2VDlSVnZXVDJ0VWFxeERTOTJ6ckdVYld6VVlrOW1TczgycEVDSCtma3FzRHQ5M1ZXKys0WXNSL2RIQ1ljUVNZVE8vS2FCTURqOUxTRC9KLyt6MjBLcThYdlpVQUlIdG05aFJQUDNJdGJ1QXUySG01bGtQczkycGQ3a0N4Z1JzMHhPVkJuWjEzY2NkQTBhdW5yd3Y5U2RxRWxKUkMzZytvQ3Urblh5Q2dtWFVzOXlNalRNQUlIZnhaVithUEtjWmVVQld0MDU3WG84NUtzMUlyNWd6RUhDV3FaRWhyTFpNdUYxMXppR3RGUVVkcy9FRVNhamhhZ3pjS3N4YW1jU1p4R3RoNFVJSSthZFBoUWtVbngyV3lOKzRZV1IrcjNmOE1ua3lHRnVSNHpqenhKUzhXc1FZUjVQVHlSYUQ5aXhhNk1oNzQxbkJIYnpmalhIc2tHRHExNzl4YVJOckNJQjF6MXhSZldmanF3MnBIYzF6azl4bFBwTDhzUVdBSXVFVFpaaGJubUw1NHJjZVhWTlJ2VWlLcnJxSWtlb2dzbDBYWGIxN3lsTmIwZjRHQTlXZDQ0dmZmRUc4RlNaR0hFTDJmYmFUR1JjU2lDZUE4UG1BL2Y2SHo4SENTNzZmWFVId2d3a3pTd2xJNzFla1o3RmFwbWxrL0tDK0hzOGhVY3czTjJMTjVMaGtWWXlpellGbC91UGVWUDVsc29KSGhoZld2dlNXcnVDVVcxWmNKT2V1VGJyRGd5d0ovcUcwN2daSnBsblR2TGNZZE5hSDBLTVlPWU1HWCtyQjROR1BGbVFzTmFJd2xXcmZDZXp4cmU4elhCcnNNVCtlZFZMYkxxTjFCcUI3NkpINEJ2WlRxVUlNZkd3UEdFbitFbm1UVjg2ZlBCYVliRkwzREZFaGpCNDVDZXdrWEVBdEp4azQvTXMycFBYbmFScWRreTBIT1lkY1VjRTJ6Y1hxNHZhSXZXMi92MG5IRkpIMlhYZTIydWVEbXEvMThYR3RFTFNxODVqOVg4cTB0Y05TU0tKSVg4RlR1SkYvUGY4ajVQaHFHMnUrb3N2c0x4WXJ2dmZlVkpMKzR0a2NYY3I5SlY3djBFUm1qL1g2Zk0zTkM0ajZkUzErOVVtcjJvUGF2cWlBeWRUWlBMTU5SR1kyM0xPOXpBVkRseTdqRCs3MEc1VFBQTGRoUklsNFd4Y1lqTG5NK1NOY0oyNkZPcmtySVNVdFBPYkl6NVpiM0FHNjEya3JucHkxNVJNVysxY1FqbG5XRkk2NTM4cWt5OWF4ZDJvSm1ISUhQMDhLeVAwdWJHTytUUU5PWXV2MnVoMTd5Q0l2UjhWY1N0dzdvMWcwTk02MHNrKzhUcTdZZklCSnJ0cDUzR2t2elhIN09BMHA4L24vdTFzYXRmL1ZKaHRSMWw4V2E2R21hdWc3aGFTcGFDYVlRYXg2dGEwbWt1dGxiK2VBT1NHMWFvYk04MUQ5QTRpUzFSUmx6QkJvVlg2dFUxUzZXRTJOOU9SWTZEZmVMUkM0bDlSdnI1aDk1WERXQjJtUjFkNFdGdWRwc2dWWXdpVHdUMzFsanNrRDhaeURPbG01RGtHaDlOL1VCLzBBSTVYdmI4WkJtYWkyaFE0QldNcUZ3WW56eHdCMjZZSFNPdjlXZ1kzSlhudm9OKzJSNHJxR1ZoL0xMRE10cEZQK1NwTUdKTld2YklsNVNPb2RiQ2N6VzJSS2xla3NQb1VlR0V6cmp0S0hWZHRaQStrZnFPK3JWeC9pY2xDcXdvb3BlcHZKcFNURGpUK2I5R1d5bEdSRjhFRGJHbHc2ZVV6bUpNOTVPdm96K2t3TFgzYzJmVGpGZVlFc0U3dlVabTNtcWRHSnVLaDJ3OS9RR1NhcVJIczk5YVNjR09kRHFrRmNBQ29xZGJCb1FxcWphbWhINlE5bmczOUpDZzNsckdKd2Q1MFFrOW92bnFCVHI4TU1FN1BzMndpVmZ5Z1VtUG9VQkpKZkpXWDVOZGEwbnVuY2JGa0E9PScpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY2x1ZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_post_check: () => (/* binding */ ens_normalize_post_check)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _include_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./include.js */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nconst r = (0,_include_js__WEBPACK_IMPORTED_MODULE_0__.getData)();\n\n// @TODO: This should be lazily loaded\nconst VALID = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst IGNORED = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst MAPPED = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_mapped_map)(r);\nconst EMOJI_ROOT = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_emoji_trie)(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8CodePoints)(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nfunction ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nfunction ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2xpYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQ25CO0FBQ3ZDLFVBQVUsb0RBQU87QUFDa0U7QUFDbkY7QUFDQSxzQkFBc0IsOERBQWlCO0FBQ3ZDLHdCQUF3Qiw4REFBaUI7QUFDekMsZUFBZSw0REFBZTtBQUM5QixtQkFBbUIsNERBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0VBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxLQUFLLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx5REFBeUQ7QUFDekQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9saWIuanM/NGQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgdG9VdGY4Q29kZVBvaW50cyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBnZXREYXRhIH0gZnJvbSAnLi9pbmNsdWRlLmpzJztcbmNvbnN0IHIgPSBnZXREYXRhKCk7XG5pbXBvcnQgeyByZWFkX21lbWJlcl9hcnJheSwgcmVhZF9tYXBwZWRfbWFwLCByZWFkX2Vtb2ppX3RyaWUgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGxhemlseSBsb2FkZWRcbmNvbnN0IFZBTElEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBJR05PUkVEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBNQVBQRUQgPSByZWFkX21hcHBlZF9tYXAocik7XG5jb25zdCBFTU9KSV9ST09UID0gcmVhZF9lbW9qaV90cmllKHIpO1xuLy9jb25zdCBORkNfQ0hFQ0sgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIsIEFycmF5LmZyb20oVkFMSUQudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSkpO1xuLy9jb25zdCBTVE9QID0gMHgyRTtcbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XG5jb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcbmZ1bmN0aW9uIGV4cGxvZGVfY3AobmFtZSkge1xuICAgIHJldHVybiB0b1V0ZjhDb2RlUG9pbnRzKG5hbWUpO1xufVxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XG4gICAgcmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gMHhGRTBGKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2sobmFtZSkge1xuICAgIGZvciAobGV0IGxhYmVsIG9mIG5hbWUuc3BsaXQoJy4nKSkge1xuICAgICAgICBsZXQgY3BzID0gZXhwbG9kZV9jcChsYWJlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3BzW2ldICE9PSBVTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZXJzY29yZSBvbmx5IGFsbG93ZWQgYXQgc3RhcnRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwcy5ldmVyeShjcCA9PiBjcCA8IDB4ODApICYmIGNwc1syXSA9PT0gSFlQSEVOICYmIGNwc1szXSA9PT0gSFlQSEVOKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsYWJlbCBcIiR7bGFiZWx9XCI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemVfcG9zdF9jaGVjayhub3JtYWxpemUobmFtZSwgZmlsdGVyX2ZlMGYpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBlbW9qaV9maWx0ZXIpIHtcbiAgICBsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTsgLy8gZmxpcCBmb3IgcG9wXG4gICAgbGV0IG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XG4gICAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goLi4uZW1vamlfZmlsdGVyKGVtb2ppKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3AgPSBpbnB1dC5wb3AoKTtcbiAgICAgICAgaWYgKFZBTElELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJR05PUkVELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjcHMgPSBNQVBQRURbY3BdO1xuICAgICAgICBpZiAoY3BzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5jcHMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNhbGxvd2VkIGNvZGVwb2ludDogMHgke2NwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZV9wb3N0X2NoZWNrKG5mYyhTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpKSk7XG59XG5mdW5jdGlvbiBuZmMocykge1xuICAgIHJldHVybiBzLm5vcm1hbGl6ZSgnTkZDJyk7XG59XG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5vZGUgPSBFTU9KSV9ST09UO1xuICAgIGxldCBlbW9qaTtcbiAgICBsZXQgc2F2ZWQ7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IHBvcyA9IGNwcy5sZW5ndGg7XG4gICAgaWYgKGVhdGVuKVxuICAgICAgICBlYXRlbi5sZW5ndGggPSAwOyAvLyBjbGVhciBpbnB1dCBidWZmZXIgKGlmIG5lZWRlZClcbiAgICB3aGlsZSAocG9zKSB7XG4gICAgICAgIGxldCBjcCA9IGNwc1stLXBvc107XG4gICAgICAgIG5vZGUgPSAoX2EgPSBub2RlLmJyYW5jaGVzLmZpbmQoeCA9PiB4LnNldC5oYXMoY3ApKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobm9kZS5zYXZlKSB7IC8vIHJlbWVtYmVyXG4gICAgICAgICAgICBzYXZlZCA9IGNwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuY2hlY2spIHsgLy8gY2hlY2sgZXhjbHVzaW9uXG4gICAgICAgICAgICBpZiAoY3AgPT09IHNhdmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goY3ApO1xuICAgICAgICBpZiAobm9kZS5mZTBmKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKDB4RkUwRik7XG4gICAgICAgICAgICBpZiAocG9zID4gMCAmJiBjcHNbcG9zIC0gMV0gPT0gMHhGRTBGKVxuICAgICAgICAgICAgICAgIHBvcy0tOyAvLyBjb25zdW1lIG9wdGlvbmFsIEZFMEZcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52YWxpZCkgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcbiAgICAgICAgICAgIGVtb2ppID0gc3RhY2suc2xpY2UoKTsgLy8gY29weSBzdGFja1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsaWQgPT0gMilcbiAgICAgICAgICAgICAgICBlbW9qaS5zcGxpY2UoMSwgMSk7IC8vIGRlbGV0ZSBGRTBGIGF0IHBvc2l0aW9uIDEgKFJHSSBaV0ogZG9uJ3QgZm9sbG93IHNwZWMhKVxuICAgICAgICAgICAgaWYgKGVhdGVuKVxuICAgICAgICAgICAgICAgIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gY29weSBpbnB1dCAoaWYgbmVlZGVkKVxuICAgICAgICAgICAgY3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1vamk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/id.js":
/*!************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n\n\nfunction id(text) {\n    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));\n}\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDQTtBQUM5QztBQUNQLFdBQVcsbUVBQVMsQ0FBQyxtRUFBVztBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzPzU0M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHRleHQpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/id.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ens-normalize/lib */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)((0,_ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__.ens_normalize)(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nfunction ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8String)(comp)).join(\".\");\n}\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)([result, (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)(comps.pop())]));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)(result);\n}\nfunction dnsEncode(name) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ1k7QUFDZDtBQUNOO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQVcsQ0FBQyxpRUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNENBQTRDLG9FQUFZO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQVMsQ0FBQyw0REFBTSxVQUFVLG1FQUFTO0FBQ3BEO0FBQ0EsV0FBVyw2REFBTztBQUNsQjtBQUNPO0FBQ1AsV0FBVyw2REFBTyxDQUFDLDREQUFNO0FBQ3pCO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzPzgyMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiLi9lbnMtbm9ybWFsaXplL2xpYlwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGlmIChjb21wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc19ub3JtYWxpemUobmFtZSkpO1xuICAgIGNvbnN0IGNvbXBzID0gW107XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wcztcbiAgICB9XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGJ5dGVzW2ldO1xuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCwgaSkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgIGlmIChsYXN0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4gdG9VdGY4U3RyaW5nKGNvbXApKS5qb2luKFwiLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1Nihjb21wcy5wb3AoKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUpIHtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAvLyBETlMgZG9lcyBub3QgYWxsb3cgY29tcG9uZW50cyBvdmVyIDYzIGJ5dGVzIGluIGxlbmd0aFxuICAgICAgICBpZiAoY29tcC5sZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBETlMgZW5jb2RlZCBlbnRyeTsgbGVuZ3RoIGV4Y2VlZHMgNjMgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/namehash.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./id */ \"(ssr)/../../node_modules/@ethersproject/hash/lib.esm/id.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nconst Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(1);\nconst MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n}\nconst hexTrue = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(One.toHexString(), 32);\nconst hexFalse = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"types\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.deepCopy)(types)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_encoderCache\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256);\n                }\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNvRDtBQUNDO0FBQ3dDO0FBQ3hDO0FBQzZCO0FBQ25DO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDUDtBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFTO0FBQzdCLGFBQWEsK0RBQVM7QUFDdEIsWUFBWSwrREFBUztBQUNyQixtQkFBbUIsK0RBQVM7QUFDNUI7QUFDQSxrQkFBa0IsOERBQVE7QUFDMUI7QUFDQTtBQUNBLGVBQWUsK0RBQVM7QUFDeEI7QUFDQSxXQUFXLDZEQUFPO0FBQ2xCO0FBQ0EsZ0JBQWdCLGdFQUFVO0FBQzFCLGlCQUFpQixnRUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0IsYUFBYSxJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixrRUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQiw4REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFTO0FBQ25DO0FBQ0EseUVBQXlFLEtBQUs7QUFDOUU7QUFDQSx1QkFBdUIsZ0VBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFRO0FBQ3RDO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQVUsQ0FBQyxrRUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1FQUFTO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxHQUFHLGNBQWMsWUFBWSxvQ0FBb0M7QUFDcEY7QUFDTztBQUNQO0FBQ0EsUUFBUSx5RUFBYyw4QkFBOEIsbUVBQVE7QUFDNUQsUUFBUSx5RUFBYywwQkFBMEI7QUFDaEQsUUFBUSx5RUFBYyxtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw0QkFBNEIsS0FBSyxxQkFBcUI7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx5QkFBeUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUJBQXlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHdEQUF3RDtBQUMxSTtBQUNBLFFBQVEseUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxtQkFBbUIsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0RBQVM7QUFDakQ7QUFDQSx1QkFBdUIsbUVBQVMsQ0FBQywrREFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVDQUFFO0FBQ2xDO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBLCtCQUErQixtRUFBUztBQUN4QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1FQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxtQkFBbUIsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHFCQUFxQjtBQUNqRztBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2REFBNkQsNEJBQTRCO0FBQ3pGO0FBQ0E7QUFDQSxlQUFlLCtEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzRUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUVBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlFQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0NBQW9DO0FBQ25FLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxzRUFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQU8sQ0FBQyw4REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vdHlwZWQtZGF0YS5qcz8xOTA4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4Q29uY2F0LCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgTmVnYXRpdmVPbmUgPSBCaWdOdW1iZXIuZnJvbSgtMSk7XG5jb25zdCBaZXJvID0gQmlnTnVtYmVyLmZyb20oMCk7XG5jb25zdCBPbmUgPSBCaWdOdW1iZXIuZnJvbSgxKTtcbmNvbnN0IE1heFVpbnQyNTYgPSBCaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSBoZXhaZXJvUGFkKE9uZS50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IGhleFplcm9QYWQoWmVyby50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IGRvbWFpbkNoZWNrcyA9IHtcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXG4gICAgdmVyc2lvbjogY2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLFxuICAgIGNoYWluSWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgXCJjaGFpbklkXCJgLCBcImRvbWFpbi5jaGFpbklkXCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAlIDggIT09IDAgfHwgd2lkdGggPiAyNTYgfHwgKG1hdGNoWzJdICYmIG1hdGNoWzJdICE9PSBTdHJpbmcod2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBNYXhVaW50MjU2Lm1hc2soc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/IGJvdW5kc1VwcGVyLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkgOiBaZXJvO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHYubHQoYm91bmRzTG93ZXIpIHx8IHYuZ3QoYm91bmRzVXBwZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodi50b1R3b3MoMjU2KS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IHdpZHRoID4gMzIgfHwgbWF0Y2hbMV0gIT09IFN0cmluZyh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidHlwZXNcIiwgT2JqZWN0LmZyZWV6ZShkZWVwQ29weSh0eXBlcykpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZW5jb2RlckNhY2hlXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfdHlwZXNcIiwge30pO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IHt9O1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0ge307XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGlua3NbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIHBhcmVudHNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIHN1YnR5cGVzW3R5cGVdID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgICAgICB0eXBlc1tuYW1lXS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlTmFtZXNbZmllbGQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbZmllbGQubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLylbMV07XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VUeXBlID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHNbYmFzZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzW2Jhc2VUeXBlXS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzW25hbWVdW2Jhc2VUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzW25dLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpbWFyeVR5cGVcIiwgcHJpbWFyeVR5cGVzWzBdKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZm91bmRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmRbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobGlua3NbdHlwZV0pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2NoaWxkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3VuZCkuZm9yRWFjaCgoc3VidHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlc1tzdWJ0eXBlXVtjaGlsZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgZm91bmRbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCB7fSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBPYmplY3Qua2V5cyhzdWJ0eXBlc1tuYW1lXSk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLl90eXBlc1tuYW1lXSA9IGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV07XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXSA9IHRoaXMuX2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgIF9nZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZXNbc3VidHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleENvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy5fdHlwZXNbdHlwZV0pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhDb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3R5cGVzW25hbWVdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChzdWJ0eXBlLCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIHN0YXRpYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgICAgIGRvbWFpbiA9IHNoYWxsb3dDb3B5KGRvbWFpbik7XG4gICAgICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSB5aWVsZCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gc2hhbGxvd0NvcHkodHlwZXMpO1xuICAgICAgICBpZiAodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXJyYXlpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgc3RyaW5nYCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/hash/lib.esm/typed-data.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/../../node_modules/js-sha3/src/sha3.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\n\nfunction keccak256(data) {\n    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUNjO0FBQ3FCO0FBQ3pDO0FBQ1Asa0JBQWtCLHlEQUFlLENBQUMsOERBQVE7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzPzI1NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgc2hhMyBmcm9tIFwianMtc2hhM1wiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoZGF0YSkge1xuICAgIHJldHVybiAnMHgnICsgc2hhMy5rZWNjYWtfMjU2KGFycmF5aWZ5KGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"logger/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanM/ZjM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwibG9nZ2VyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/logger/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/_version.js\");\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUN0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxLQUFLO0FBQ3pDLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcseURBQXlELHFDQUFxQztBQUN6TTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzP2JjNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEludGVyYWN0aW9uIEVycm9yc1xuICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBhY3Rpb24sIHN1Y2ggYXMgc2lnbmluZyBhIG1lc3NhZ2Ugb3Igc2VuZGluZ1xuICAgIC8vIGEgdHJhbnNhY3Rpb25cbiAgICBFcnJvckNvZGVbXCJBQ1RJT05fUkVKRUNURURcIl0gPSBcIkFDVElPTl9SRUpFQ1RFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuO1xuY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2NlbnNvckVycm9ycyA9ICEhY2Vuc29yc2hpcDtcbiAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgfVxufVxuTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"networks/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzP2YxYzMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/networks/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/networks/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNetwork: () => (/* binding */ getNetwork)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/networks/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.QuickNodeProvider && options.quicknode !== \"-\") {\n            try {\n                providerList.push(new providers.QuickNodeProvider(network, options.quicknode));\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    holesky: {\n        chainId: 17000,\n        name: \"holesky\",\n        _defaultProvider: ethDefaultProvider(\"holesky\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: {\n        chainId: 80001,\n        name: \"maticmum\",\n        _defaultProvider: ethDefaultProvider(\"maticmum\")\n    },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    \"optimism-sepolia\": { chainId: 11155420, name: \"optimism-sepolia\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    \"arbitrum-sepolia\": { chainId: 421614, name: \"arbitrum-sepolia\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nfunction getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLHFDQUFxQztBQUM3RCx5QkFBeUIsdUNBQXVDO0FBQ2hFLDBCQUEwQiw2Q0FBNkM7QUFDdkUsZ0JBQWdCLGtDQUFrQztBQUNsRCwwQkFBMEIsMkNBQTJDO0FBQ3JFLHlCQUF5QiwwQ0FBMEM7QUFDbkUsMEJBQTBCLDJDQUEyQztBQUNyRSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL2luZGV4LmpzP2M5MzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG5mdW5jdGlvbiBpc1JlbmV0d29ya2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVuZXR3b3JrKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKSB7XG4gICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTGlzdCA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyICYmIG9wdGlvbnMuaW5mdXJhICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuaW5mdXJhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIgJiYgb3B0aW9ucy5ldGhlcnNjYW4gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIgJiYgb3B0aW9ucy5hbGNoZW15ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFsY2hlbXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlciAmJiBvcHRpb25zLnBvY2tldCAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIG5ldHdvcmtzIGFyZSBjdXJyZW50bHkgZmF1bHR5IG9uIFBvY2tldCBhcyB0aGVpclxuICAgICAgICAgICAgLy8gbmV0d29yayBkb2VzIG5vdCBoYW5kbGUgdGhlIEJlcmxpbiBoYXJkZm9yaywgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGxpdmUgb24gdGhlc2Ugb25lcy5cbiAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIGdvZXMgYXdheSBvbmNlIFBvY2tldCBoYXMgdXBncmFkZWQgdGhlaXIgbm9kZXNcbiAgICAgICAgICAgIGNvbnN0IHNraXAgPSBbXCJnb2VybGlcIiwgXCJyb3BzdGVuXCIsIFwicmlua2VieVwiLCBcInNlcG9saWFcIl07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLnBvY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm5ldHdvcmsgJiYgc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyICYmIG9wdGlvbnMuY2xvdWRmbGFyZSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFua3JQcm92aWRlciAmJiBvcHRpb25zLmFua3IgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBbXCJyb3BzdGVuXCJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5BbmtyUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbmtyKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubmV0d29yayAmJiBza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5RdWlja05vZGVQcm92aWRlciAmJiBvcHRpb25zLnF1aWNrbm9kZSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5RdWlja05vZGVQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLnF1aWNrbm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgcXVvcnVtID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuY29uc3QgaG9tZXN0ZWFkID0ge1xuICAgIGNoYWluSWQ6IDEsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxufTtcbmNvbnN0IHJvcHN0ZW4gPSB7XG4gICAgY2hhaW5JZDogMyxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwicm9wc3RlblwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcbn07XG5jb25zdCBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcbiAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcbiAgICBtYWlubmV0OiBob21lc3RlYWQsXG4gICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcbiAgICByb3BzdGVuOiByb3BzdGVuLFxuICAgIHRlc3RuZXQ6IHJvcHN0ZW4sXG4gICAgcmlua2VieToge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuICAgIH0sXG4gICAga292YW46IHtcbiAgICAgICAgY2hhaW5JZDogNDIsXG4gICAgICAgIG5hbWU6IFwia292YW5cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcbiAgICB9LFxuICAgIGdvZXJsaToge1xuICAgICAgICBjaGFpbklkOiA1LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcImdvZXJsaVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcbiAgICB9LFxuICAgIGtpbnRzdWdpOiB7IGNoYWluSWQ6IDEzMzc3MDIsIG5hbWU6IFwia2ludHN1Z2lcIiB9LFxuICAgIHNlcG9saWE6IHtcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXG4gICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgICAgIG5hbWU6IFwic2Vwb2xpYVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJzZXBvbGlhXCIpXG4gICAgfSxcbiAgICBob2xlc2t5OiB7XG4gICAgICAgIGNoYWluSWQ6IDE3MDAwLFxuICAgICAgICBuYW1lOiBcImhvbGVza3lcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiaG9sZXNreVwiKVxuICAgIH0sXG4gICAgLy8gRVRDIChTZWU6ICMzNTEpXG4gICAgY2xhc3NpYzoge1xuICAgICAgICBjaGFpbklkOiA2MSxcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9ldGNcIiwgXCJjbGFzc2ljXCIpXG4gICAgfSxcbiAgICBjbGFzc2ljTW9yZGVuOiB7IGNoYWluSWQ6IDYyLCBuYW1lOiBcImNsYXNzaWNNb3JkZW5cIiB9LFxuICAgIGNsYXNzaWNNb3Jkb3I6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY1Rlc3RuZXQ6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY0tvdHRpOiB7XG4gICAgICAgIGNoYWluSWQ6IDYsXG4gICAgICAgIG5hbWU6IFwiY2xhc3NpY0tvdHRpXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9rb3R0aVwiLCBcImNsYXNzaWNLb3R0aVwiKVxuICAgIH0sXG4gICAgeGRhaTogeyBjaGFpbklkOiAxMDAsIG5hbWU6IFwieGRhaVwiIH0sXG4gICAgbWF0aWM6IHtcbiAgICAgICAgY2hhaW5JZDogMTM3LFxuICAgICAgICBuYW1lOiBcIm1hdGljXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcIm1hdGljXCIpXG4gICAgfSxcbiAgICBtYXRpY211bToge1xuICAgICAgICBjaGFpbklkOiA4MDAwMSxcbiAgICAgICAgbmFtZTogXCJtYXRpY211bVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJtYXRpY211bVwiKVxuICAgIH0sXG4gICAgb3B0aW1pc206IHtcbiAgICAgICAgY2hhaW5JZDogMTAsXG4gICAgICAgIG5hbWU6IFwib3B0aW1pc21cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwib3B0aW1pc21cIilcbiAgICB9LFxuICAgIFwib3B0aW1pc20ta292YW5cIjogeyBjaGFpbklkOiA2OSwgbmFtZTogXCJvcHRpbWlzbS1rb3ZhblwiIH0sXG4gICAgXCJvcHRpbWlzbS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjAsIG5hbWU6IFwib3B0aW1pc20tZ29lcmxpXCIgfSxcbiAgICBcIm9wdGltaXNtLXNlcG9saWFcIjogeyBjaGFpbklkOiAxMTE1NTQyMCwgbmFtZTogXCJvcHRpbWlzbS1zZXBvbGlhXCIgfSxcbiAgICBhcmJpdHJ1bTogeyBjaGFpbklkOiA0MjE2MSwgbmFtZTogXCJhcmJpdHJ1bVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1yaW5rZWJ5XCI6IHsgY2hhaW5JZDogNDIxNjExLCBuYW1lOiBcImFyYml0cnVtLXJpbmtlYnlcIiB9LFxuICAgIFwiYXJiaXRydW0tZ29lcmxpXCI6IHsgY2hhaW5JZDogNDIxNjEzLCBuYW1lOiBcImFyYml0cnVtLWdvZXJsaVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6IHsgY2hhaW5JZDogNDIxNjE0LCBuYW1lOiBcImFyYml0cnVtLXNlcG9saWFcIiB9LFxuICAgIGJuYjogeyBjaGFpbklkOiA1NiwgbmFtZTogXCJibmJcIiB9LFxuICAgIGJuYnQ6IHsgY2hhaW5JZDogOTcsIG5hbWU6IFwiYm5idFwiIH0sXG59O1xuLyoqXG4gKiAgZ2V0TmV0d29ya1xuICpcbiAqICBDb252ZXJ0cyBhIG5hbWVkIGNvbW1vbiBuZXR3b3JrcyBvciBjaGFpbiBJRCAobmV0d29yayBJRCkgdG8gYSBOZXR3b3JrXG4gKiAgYW5kIHZlcmlmaWVzIGEgbmV0d29yayBpcyBhIHZhbGlkIE5ldHdvcmsuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgLy8gTm8gbmV0d29yayAobnVsbClcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmV0d29ya3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYXJkID0gbmV0d29ya3NbbmFtZV07XG4gICAgICAgICAgICBpZiAoc3RhbmRhcmQuY2hhaW5JZCA9PT0gbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGVuc0FkZHJlc3M6IChzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmssXG4gICAgICAgICAgICBuYW1lOiBcInVua25vd25cIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmtdO1xuICAgICAgICBpZiAoc3RhbmRhcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkLm5hbWUsXG4gICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgZW5zQWRkcmVzczogc3RhbmRhcmQuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IChzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YW5kYXJkID0gbmV0d29ya3NbbmV0d29yay5uYW1lXTtcbiAgICAvLyBOb3QgYSBzdGFuZGFyZCBuZXR3b3JrOyBjaGVjayB0aGF0IGl0IGlzIGEgdmFsaWQgbmV0d29yayBpbiBnZW5lcmFsXG4gICAgaWYgKCFzdGFuZGFyZCkge1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYWluSWQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbmV0d29yayBjaGFpbklkIChvciBpcyAwOyBkaXNhYmxlIEVJUC0xNTUpXG4gICAgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gMCAmJiBuZXR3b3JrLmNoYWluSWQgIT09IHN0YW5kYXJkLmNoYWluSWQpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBJbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGFkZCBhbiBhdHRhY2ggZnVuY3Rpb24gdG8gYSBkZWZhdWx0UHJvdmlkZXJcbiAgICAvLyBjbGFzcyBhbmQgbW92ZSB0aGUgX2RlZmF1bHRQcm92aWRlciBpbnRlcm5hbCB0byB0aGlzIGZpbGUgKGV4dGVuZCBOZXR3b3JrKVxuICAgIGxldCBkZWZhdWx0UHJvdmlkZXIgPSBuZXR3b3JrLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbDtcbiAgICBpZiAoZGVmYXVsdFByb3ZpZGVyID09IG51bGwgJiYgc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcikge1xuICAgICAgICBpZiAoaXNSZW5ldHdvcmthYmxlKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyLnJlbmV0d29yayhuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RhbmRhcmQgTmV0d29yayAoYWxsb3cgb3ZlcnJpZGluZyB0aGUgRU5TIGFkZHJlc3MpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmV0d29yay5uYW1lLFxuICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICBlbnNBZGRyZXNzOiAobmV0d29yay5lbnNBZGRyZXNzIHx8IHN0YW5kYXJkLmVuc0FkZHJlc3MgfHwgbnVsbCksXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlclxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/networks/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"properties/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcz85ZWY2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/properties/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Description: () => (/* binding */ Description),\n/* harmony export */   checkProperties: () => (/* binding */ checkProperties),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   defineReadOnly: () => (/* binding */ defineReadOnly),\n/* harmony export */   getStatic: () => (/* binding */ getStatic),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   shallowCopy: () => (/* binding */ shallowCopy)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUMrQztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vaW5kZXguanM/OTdhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gQ3Jhd2wgdXAgdGhlIGNvbnN0cnVjdG9yIGNoYWluIHRvIGZpbmQgYSBzdGF0aWMgbWV0aG9kXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljKGN0b3IsIGtleSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBpZiAoY3RvcltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gY3RvcltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKCh2KSA9PiAoeyBrZXk6IGtleSwgdmFsdWU6IHYgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiAob2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdCBrZXkgLSBcIiArIGtleSwgXCJ0cmFuc2FjdGlvbjpcIiArIGtleSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iamVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgb3BhcXVlID0geyBiaWdpbnQ6IHRydWUsIGJvb2xlYW46IHRydWUsIFwiZnVuY3Rpb25cIjogdHJ1ZSwgbnVtYmVyOiB0cnVlLCBzdHJpbmc6IHRydWUgfTtcbmZ1bmN0aW9uIF9pc0Zyb3plbihvYmplY3QpIHtcbiAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBvcGFxdWVbdHlwZW9mIChvYmplY3QpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSB8fCB0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWNjZXNzaW5nIGEgdmFsdWUgdHJpZ2dlcnMgYW4gZXJyb3IsIGl0IGlzIGEgZ2V0dGVyXG4gICAgICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gZG8gc28gKGUuZy4gUmVzdWx0KSBhbmQgaXMgdGhlcmVmb3JlIFwiZnJvemVuXCJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzRnJvemVuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuLy8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuLy8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cbmZ1bmN0aW9uIF9kZWVwQ29weShvYmplY3QpIHtcbiAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdC5tYXAoKGl0ZW0pID0+IGRlZXBDb3B5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShyZXN1bHQsIGtleSwgZGVlcENvcHkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9kZWVwQ29weShvYmplY3QpO1xufVxuZXhwb3J0IGNsYXNzIERlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IGRlZXBDb3B5KGluZm9ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"rlp/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vX3ZlcnNpb24uanM/NzI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicmxwLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/_version.js\");\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset]) };\n}\nfunction decode(data) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNzRTtBQUN2QjtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFXO0FBQ3BCO0FBQ0E7QUFDQSw0Q0FBNEMsOERBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUFNLDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0Q0FBNEMseURBQU0sMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseURBQU0sMEJBQTBCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBTSwwQkFBMEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUFNLDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseURBQU0sMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5REFBTSwwQkFBMEI7QUFDdEY7QUFDQSx1QkFBdUIsNkRBQU87QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlEQUFNLDBCQUEwQjtBQUNoRjtBQUNBLHVCQUF1Qiw2REFBTztBQUM5QixpQkFBaUI7QUFDakI7QUFDQSxhQUFhLHFCQUFxQiw2REFBTztBQUN6QztBQUNPO0FBQ1Asa0JBQWtCLDhEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vaW5kZXguanM/ZWUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoIWlzQnl0ZXNMaWtlKG9iamVjdCkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlJMUCBvYmplY3QgbXVzdCBiZSBCeXRlc0xpa2VcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5aWZ5KG9iamVjdCkpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgIGRhdGEudW5zaGlmdCgweDgwICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgcmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iamVjdCkge1xuICAgIHJldHVybiBoZXhsaWZ5KF9lbmNvZGUob2JqZWN0KSk7XG59XG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcbiAgICAgICAgY2hpbGRPZmZzZXQgKz0gZGVjb2RlZC5jb25zdW1lZDtcbiAgICAgICAgaWYgKGNoaWxkT2Zmc2V0ID4gb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICB9XG4gICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6IDEsIHJlc3VsdDogaGV4bGlmeShkYXRhW29mZnNldF0pIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGJ5dGVzLCAwKTtcbiAgICBpZiAoZGVjb2RlZC5jb25zdW1lZCAhPT0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"sha2/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9fdmVyc2lvbi5qcz85NTlmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaGEyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(ssr)/../../node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/types.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/_version.js\");\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nfunction ripemd160(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().ripemd160().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction sha256(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha256().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction sha512(data) {\n    return \"0x\" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha512().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\"));\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!_types__WEBPACK_IMPORTED_MODULE_4__.SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().hmac((hash_js__WEBPACK_IMPORTED_MODULE_0___default())[algorithm], (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(key)).update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNjO0FBQzNCO0FBQ2dEO0FBQ0g7QUFDRTtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1AsbUJBQW1CLHdEQUFjLFVBQVUsOERBQVE7QUFDbkQ7QUFDTztBQUNQLG1CQUFtQixxREFBVyxVQUFVLDhEQUFRO0FBQ2hEO0FBQ087QUFDUCxtQkFBbUIscURBQVcsVUFBVSw4REFBUTtBQUNoRDtBQUNPO0FBQ1AsU0FBUyxzREFBa0I7QUFDM0IsZ0VBQWdFLHlEQUFNO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsbURBQVMsQ0FBQyxnREFBSSxhQUFhLDhEQUFRLGNBQWMsOERBQVE7QUFDM0U7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzP2NiMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgaGFzaCBmcm9tIFwiaGFzaC5qc1wiO1xuLy9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupportedAlgorithm: () => (/* binding */ SupportedAlgorithm)\n/* harmony export */ });\nvar SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzPzE2ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/sha2/lib.esm/types.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"signing-key/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzPzMyOTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EC: () => (/* binding */ EC$1)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/../../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(ssr)/../../node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getDefaultExportFromNamespaceIfPresent (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n}\n\nfunction getDefaultExportFromNamespaceIfNotNamed (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n}\n\nfunction getAugmentedNamespace(n) {\n\tif (n.__esModule) return n;\n\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar minimalisticAssert = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\nvar utils_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n});\n\nvar utils_1$1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\n\n\n\nutils.assert = minimalisticAssert;\nutils.toArray = utils_1.toArray;\nutils.zero2 = utils_1.zero2;\nutils.toHex = utils_1.toHex;\nutils.encode = utils_1.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  var i;\n  for (i = 0; i < naf.length; i += 1) {\n    naf[i] = 0;\n  }\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n});\n\n'use strict';\n\n\n\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default().red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(this.p);\n\n  // Useful for many curves\n  this.zero = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0).toRed(this.red);\n  this.one = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1).toRed(this.red);\n  this.two = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nvar base = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert$1(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert$1(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils_1$1.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert$1(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils_1$1.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\nvar inherits_browser = createCommonjsModule(function (module) {\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n});\n\n'use strict';\n\n\n\n\n\n\nvar assert$2 = utils_1$1.assert;\n\nfunction ShortCurve(conf) {\n  base.call(this, 'short', conf);\n\n  this.a = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.a, 16).toRed(this.red);\n  this.b = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.a, 16),\n        b: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(num);\n  var tinv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n  var y1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  var x2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  var y2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits_browser(Point, base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n  } else {\n    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nvar curve_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curve = exports;\n\ncurve.base = base;\ncurve.short = short_1;\ncurve.mont = /*RicMoo:ethers:require(./mont)*/(null);\ncurve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);\n});\n\nvar curves_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curves = exports;\n\n\n\n\n\nvar assert = utils_1$1.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve_1.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve_1.edwards(options);\n  else\n    this.curve = new curve_1.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha384),\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha512),\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n});\n\n'use strict';\n\n\n\n\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new (hash_js__WEBPACK_IMPORTED_MODULE_1___default().hmac)(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils_1.toArray(entropy, entropyEnc);\n  add = utils_1.toArray(add, addEnc);\n\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils_1.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils_1.encode(res, enc);\n};\n\n'use strict';\n\n\n\nvar assert$3 = utils_1$1.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert$3(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert$3(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert$3(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature, options) {\n  return this.ec.verify(msg, signature, this, undefined, options);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n'use strict';\n\n\n\n\nvar assert$4 = utils_1$1.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert$4(options.r && options.s, 'Signature without r or s');\n  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.r, 16);\n  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  if(buf[p.place] === 0x00) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils_1$1.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  if ((data[p.place] & 128) !== 0) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  if ((data[p.place] & 128) !== 0) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(r);\n  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils_1$1.encode(res, enc);\n};\n\n'use strict';\n\n\n\n\n\nvar rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nvar assert$5 = utils_1$1.assert;\n\n\n\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),\n      'Unknown curve ' + options);\n\n    options = curves_1[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves_1.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new key(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return key.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return key.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2));\n  for (;;) {\n    var priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {\n  var byteLength;\n  if (bn_js__WEBPACK_IMPORTED_MODULE_0___default().isBN(msg) || typeof msg === 'number') {\n    msg = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16);\n    byteLength = msg.byteLength();\n  } else if (typeof msg === 'object') {\n    // BN assumes an array-like input and asserts length\n    byteLength = msg.length;\n    msg = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16);\n  } else {\n    // BN converts the value to string\n    var str = msg.toString();\n    // HEX encoding\n    byteLength = (str.length + 1) >>> 1;\n    msg = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(str, 16);\n  }\n  // Allow overriding\n  if (typeof bitLength !== 'number') {\n    bitLength = byteLength * 8;\n  }\n  var delta = bitLength - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  if (typeof msg !== 'string' && typeof msg !== 'number' && !bn_js__WEBPACK_IMPORTED_MODULE_0___default().isBN(msg)) {\n    assert$5(typeof msg === 'object' && msg && typeof msg.length === 'number',\n      'Expected message to be an array-like, a hex string, or a BN instance');\n    assert$5((msg.length >>> 0) === msg.length); // non-negative 32-bit integer\n    for (var i = 0; i < msg.length; i++) assert$5((msg[i] & 255) === msg[i]);\n  }\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(msg, false, options.msgBitLength);\n\n  // Would fail further checks, but let's make the error message clear\n  assert$5(!msg.isNeg(), 'Can not sign a negative message');\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Recheck nonce to be bijective to msg\n  assert$5((new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(nonce)).eq(msg), 'Can not sign message');\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature$1, key, enc, options) {\n  if (!options)\n    options = {};\n\n  msg = this._truncateToN(msg, false, options.msgBitLength);\n  key = this.keyFromPublic(key, enc);\n  signature$1 = new signature(signature$1, 'hex');\n\n  // Perform primitive values validation\n  var r = signature$1.r;\n  var s = signature$1.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n  signature$1 = new signature(signature$1, enc);\n\n  var n = this.n;\n  var e = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg);\n  var r = signature$1.r;\n  var s = signature$1.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature$1.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n  signature$1 = new signature(signature$1, enc);\n  if (signature$1.recoveryParam !== null)\n    return signature$1.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature$1, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\nvar elliptic_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = /*RicMoo:ethers*/{ version: \"6.6.1\" }.version;\nelliptic.utils = utils_1$1;\nelliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nelliptic.curve = curve_1;\nelliptic.curves = curves_1;\n\n// Protocols\nelliptic.ec = ec;\nelliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);\n});\n\nvar EC$1 = elliptic_1.ec;\n\n\n//# sourceMappingURL=elliptic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vZWxsaXB0aWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUI7QUFDSTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQixZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhDQUFFO0FBQ2Y7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsOENBQUU7O0FBRWpCO0FBQ0EsMEJBQTBCLGdEQUFNLGVBQWUsaURBQU87O0FBRXREO0FBQ0Esa0JBQWtCLDhDQUFFO0FBQ3BCLGlCQUFpQiw4Q0FBRTtBQUNuQixpQkFBaUIsOENBQUU7O0FBRW5CO0FBQ0EseUJBQXlCLDhDQUFFO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDhDQUFFO0FBQ2pCLGVBQWUsOENBQUU7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBRTtBQUNqQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFFO0FBQ25CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBRTtBQUNqQixlQUFlLDhDQUFFO0FBQ2pCO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBTztBQUMvQyxpQkFBaUIsOENBQUU7QUFDbkI7O0FBRUEsY0FBYyw4Q0FBRTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBRTtBQUNqQixlQUFlLDhDQUFFO0FBQ2pCLGVBQWUsOENBQUU7QUFDakIsZUFBZSw4Q0FBRTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sY0FBYztBQUNwQixNQUFNLGNBQWM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFVBQVUsOENBQUU7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLDhDQUFFO0FBQ25CLGlCQUFpQiw4Q0FBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOENBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUU7QUFDbkIsSUFBSTtBQUNKLGlCQUFpQiw4Q0FBRTtBQUNuQixpQkFBaUIsOENBQUU7QUFDbkIsaUJBQWlCLDhDQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw4Q0FBRTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7O0FBRUQ7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQSxhQUFhLHFEQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw4Q0FBRTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDhDQUFFO0FBQ2pCLGVBQWUsOENBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsOENBQUU7QUFDakIsZUFBZSw4Q0FBRTtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUEsMkRBQTJELGlDQUFpQztBQUM1Rjs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCLDhDQUFFO0FBQzdCLFNBQVM7QUFDVCxtQkFBbUIsOENBQUU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxpREFBTztBQUNiLGNBQWMsOENBQUU7QUFDaEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGNBQWMsOENBQUU7QUFDaEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsaURBQU87QUFDcEU7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw4Q0FBRTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCLDhDQUFFOztBQUU3Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFVBQVUsOENBQUU7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMENBQTBDO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDhDQUFFO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBLGdFQUFnRSxpQ0FBaUM7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vZWxsaXB0aWMuanM/YmVkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGhhc2ggZnJvbSAnaGFzaC5qcyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgYmFzZWRpciwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7XG5cdFx0cGF0aDogYmFzZWRpcixcblx0XHRleHBvcnRzOiB7fSxcblx0XHRyZXF1aXJlOiBmdW5jdGlvbiAocGF0aCwgYmFzZSkge1xuXHRcdFx0cmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLCAoYmFzZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2UgPT09IG51bGwpID8gbW9kdWxlLnBhdGggOiBiYXNlKTtcblx0XHR9XG5cdH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQgKG4pIHtcblx0cmV0dXJuIG4gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sICdkZWZhdWx0JykgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWQgKG4pIHtcblx0cmV0dXJuIG4gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sICdkZWZhdWx0JykgJiYgT2JqZWN0LmtleXMobikubGVuZ3RoID09PSAxID8gblsnZGVmYXVsdCddIDogbjtcbn1cblxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcblx0aWYgKG4uX19lc01vZHVsZSkgcmV0dXJuIG47XG5cdHZhciBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xuXHRPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBuW2tdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMnKTtcbn1cblxudmFyIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcblxudmFyIHV0aWxzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xufSk7XG5cbnZhciB1dGlsc18xJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cblxuXG5cbnV0aWxzLmFzc2VydCA9IG1pbmltYWxpc3RpY0Fzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSB1dGlsc18xLnRvQXJyYXk7XG51dGlscy56ZXJvMiA9IHV0aWxzXzEuemVybzI7XG51dGlscy50b0hleCA9IHV0aWxzXzEudG9IZXg7XG51dGlscy5lbmNvZGUgPSB1dGlsc18xLmVuY29kZTtcblxuLy8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cbmZ1bmN0aW9uIGdldE5BRihudW0sIHcsIGJpdHMpIHtcbiAgdmFyIG5hZiA9IG5ldyBBcnJheShNYXRoLm1heChudW0uYml0TGVuZ3RoKCksIGJpdHMpICsgMSk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbmFmW2ldID0gMDtcbiAgfVxuXG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHo7XG4gICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cblxuICAgIG5hZltpXSA9IHo7XG4gICAgay5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXSxcbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgdmFyIG04O1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgZ2V0TkFGID0gdXRpbHNfMSQxLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlsc18xJDEuZ2V0SlNGO1xudmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxudmFyIGJhc2UgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgdmFyIGo7XG4gIHZhciBuYWZXO1xuICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBsID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGwgPj0gajsgbC0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBsID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgbCsrO1xuICAgIGlmIChpID49IDApXG4gICAgICBsKys7XG4gICAgYWNjID0gYWNjLmRibHAobCk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQkMSh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgcG9pbnRzLFxuICBjb2VmZnMsXG4gIGxlbixcbiAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgcDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSwgLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzLCAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yIChqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlsc18xJDEudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbCxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBpbmhlcml0c19icm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG4gIH07XG59XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxudmFyIGFzc2VydCQyID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0c19icm93c2VyKFNob3J0Q3VydmUsIGJhc2UpO1xudmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXMsXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gICAgICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICAgICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBCTigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG52YXIgY3VydmVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IGJhc2U7XG5jdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5jdXJ2ZS5tb250ID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9tb250KSovKG51bGwpO1xuY3VydmUuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqLyhudWxsKTtcbn0pO1xuXG52YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG5cblxuXG5cbnZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfSxcbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZicsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCcsXG4gIF0sXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovKG51bGwpLmNyYXNoKCk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnLFxuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgIH0sXG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZSxcbiAgXSxcbn0pO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbnZhciBobWFjRHJiZyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG52YXIga2V5ID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydCQzKGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydCQzKGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgYXNzZXJ0JDMocHViLnZhbGlkYXRlKCksICdwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZCcpO1xuICB9XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cbnZhciBhc3NlcnQkNCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQkNChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG4gIHRoaXMuciA9IG5ldyBCTihvcHRpb25zLnIsIDE2KTtcbiAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgZWxzZVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbn1cbnZhciBzaWduYXR1cmUgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoIG9yIG92ZXJmbG93XG4gIGlmIChvY3RldExlbiA9PT0gMCB8fCBvY3RldExlbiA+IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZihidWZbcC5wbGFjZV0gPT09IDB4MDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gICAgdmFsID4+Pj0gMDtcbiAgfVxuXG4gIC8vIExlYWRpbmcgemVyb2VzXG4gIGlmICh2YWwgPD0gMHg3Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlsc18xJDEudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChybGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGRhdGFbcC5wbGFjZV0gJiAxMjgpICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKHNsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChkYXRhW3AucGxhY2VdICYgMTI4KSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCkge1xuICAgIGlmIChyWzFdICYgMHg4MCkge1xuICAgICAgciA9IHIuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzWzBdID09PSAwKSB7XG4gICAgaWYgKHNbMV0gJiAweDgwKSB7XG4gICAgICBzID0gcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxudmFyIHJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xudmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLCBvcHRpb25zKSxcbiAgICAgICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBjdXJ2ZXNfMVtvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzXzEuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxudmFyIGVjID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKSxcbiAgfSk7XG5cbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgZm9yICg7Oykge1xuICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHByaXYuaWFkZG4oMSk7XG4gICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiBfdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHksIGJpdExlbmd0aCkge1xuICB2YXIgYnl0ZUxlbmd0aDtcbiAgaWYgKEJOLmlzQk4obXNnKSB8fCB0eXBlb2YgbXNnID09PSAnbnVtYmVyJykge1xuICAgIG1zZyA9IG5ldyBCTihtc2csIDE2KTtcbiAgICBieXRlTGVuZ3RoID0gbXNnLmJ5dGVMZW5ndGgoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbXNnID09PSAnb2JqZWN0Jykge1xuICAgIC8vIEJOIGFzc3VtZXMgYW4gYXJyYXktbGlrZSBpbnB1dCBhbmQgYXNzZXJ0cyBsZW5ndGhcbiAgICBieXRlTGVuZ3RoID0gbXNnLmxlbmd0aDtcbiAgICBtc2cgPSBuZXcgQk4obXNnLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQk4gY29udmVydHMgdGhlIHZhbHVlIHRvIHN0cmluZ1xuICAgIHZhciBzdHIgPSBtc2cudG9TdHJpbmcoKTtcbiAgICAvLyBIRVggZW5jb2RpbmdcbiAgICBieXRlTGVuZ3RoID0gKHN0ci5sZW5ndGggKyAxKSA+Pj4gMTtcbiAgICBtc2cgPSBuZXcgQk4oc3RyLCAxNik7XG4gIH1cbiAgLy8gQWxsb3cgb3ZlcnJpZGluZ1xuICBpZiAodHlwZW9mIGJpdExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBiaXRMZW5ndGggPSBieXRlTGVuZ3RoICogODtcbiAgfVxuICB2YXIgZGVsdGEgPSBiaXRMZW5ndGggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIG1zZyAhPT0gJ251bWJlcicgJiYgIUJOLmlzQk4obXNnKSkge1xuICAgIGFzc2VydCQ1KHR5cGVvZiBtc2cgPT09ICdvYmplY3QnICYmIG1zZyAmJiB0eXBlb2YgbXNnLmxlbmd0aCA9PT0gJ251bWJlcicsXG4gICAgICAnRXhwZWN0ZWQgbWVzc2FnZSB0byBiZSBhbiBhcnJheS1saWtlLCBhIGhleCBzdHJpbmcsIG9yIGEgQk4gaW5zdGFuY2UnKTtcbiAgICBhc3NlcnQkNSgobXNnLmxlbmd0aCA+Pj4gMCkgPT09IG1zZy5sZW5ndGgpOyAvLyBub24tbmVnYXRpdmUgMzItYml0IGludGVnZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgYXNzZXJ0JDUoKG1zZ1tpXSAmIDI1NSkgPT09IG1zZ1tpXSk7XG4gIH1cblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obXNnLCBmYWxzZSwgb3B0aW9ucy5tc2dCaXRMZW5ndGgpO1xuXG4gIC8vIFdvdWxkIGZhaWwgZnVydGhlciBjaGVja3MsIGJ1dCBsZXQncyBtYWtlIHRoZSBlcnJvciBtZXNzYWdlIGNsZWFyXG4gIGFzc2VydCQ1KCFtc2cuaXNOZWcoKSwgJ0NhbiBub3Qgc2lnbiBhIG5lZ2F0aXZlIG1lc3NhZ2UnKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gUmVjaGVjayBub25jZSB0byBiZSBiaWplY3RpdmUgdG8gbXNnXG4gIGFzc2VydCQ1KChuZXcgQk4obm9uY2UpKS5lcShtc2cpLCAnQ2FuIG5vdCBzaWduIG1lc3NhZ2UnKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IDsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBzaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlJDEsIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obXNnLCBmYWxzZSwgb3B0aW9ucy5tc2dCaXRMZW5ndGgpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlJDEucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHA7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuICBhc3NlcnQkNSgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSQxLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUkMSwgaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG52YXIgZWxsaXB0aWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IC8qUmljTW9vOmV0aGVycyoveyB2ZXJzaW9uOiBcIjYuNi4xXCIgfS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5lbGxpcHRpYy5yYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcbmVsbGlwdGljLmN1cnZlID0gY3VydmVfMTtcbmVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gZWM7XG5lbGxpcHRpYy5lZGRzYSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWxsaXB0aWMvZWRkc2EpKi8obnVsbCk7XG59KTtcblxudmFyIEVDJDEgPSBlbGxpcHRpY18xLmVjO1xuXG5leHBvcnQgeyBFQyQxIGFzIEVDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGxpcHRpYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey),\n/* harmony export */   computePublicKey: () => (/* binding */ computePublicKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey)\n/* harmony export */ });\n/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elliptic */ \"(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_2__.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey) {\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"privateKey\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(privateKey));\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataLength)(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));\n        const p1 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const digestBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(computePublicKey(otherKey)));\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)(signature);\n    const rs = { r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.r), s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUNtQjtBQUNvRTtBQUN6QztBQUNaO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWMscUJBQXFCLDZEQUFPO0FBQ2xELFlBQVksbUVBQWE7QUFDekI7QUFDQTtBQUNBLGtEQUFrRCw4REFBUTtBQUMxRCxRQUFRLHlFQUFjO0FBQ3RCLFFBQVEseUVBQWM7QUFDdEIsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0EsNENBQTRDLDhEQUFRO0FBQ3BELDRDQUE0Qyw4REFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOERBQVE7QUFDMUQsNEJBQTRCLDhEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkUsZUFBZSxvRUFBYztBQUM3QjtBQUNBLGVBQWUsZ0VBQVU7QUFDekIsZUFBZSxnRUFBVTtBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRCw4REFBUTtBQUMxRCxzREFBc0QsOERBQVE7QUFDOUQsZUFBZSxnRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0Isb0VBQWM7QUFDOUIsaUJBQWlCLEdBQUcsOERBQVEsWUFBWSw4REFBUTtBQUNoRCwyQ0FBMkMsOERBQVE7QUFDbkQ7QUFDTztBQUNQLGtCQUFrQiw4REFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2luZGV4LmpzPzNiNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBFQyB9IGZyb20gXCIuL2VsbGlwdGljXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4RGF0YUxlbmd0aCwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgc3BsaXRTaWduYXR1cmUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmxldCBfY3VydmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG4gICAgaWYgKCFfY3VydmUpIHtcbiAgICAgICAgX2N1cnZlID0gbmV3IEVDKFwic2VjcDI1NmsxXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlO1xufVxuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIGhleGxpZnkocHJpdmF0ZUtleSkpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aCh0aGlzLnByaXZhdGVLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1sgUkVEQUNURUQgXV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmluZ0tleVwiLCB0cnVlKTtcbiAgICB9XG4gICAgX2FkZFBvaW50KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7XG4gICAgICAgIGNvbnN0IHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KG90aGVyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwMC5wdWIuYWRkKHAxLnB1YikuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKTtcbiAgICB9XG4gICAgc2lnbkRpZ2VzdChkaWdlc3QpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gYXJyYXlpZnkoZGlnZXN0KTtcbiAgICAgICAgaWYgKGRpZ2VzdEJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihkaWdlc3RCeXRlcywgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpZ25hdHVyZSh7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcbiAgICAgICAgICAgIHI6IGhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgICAgICBzOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcktleSkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3Qgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25pbmdLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBycyA9IHsgcjogYXJyYXlpZnkoc2lnLnIpLCBzOiBhcnJheWlmeShzaWcucykgfTtcbiAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoa2V5KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkoYnl0ZXMpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLCBcImtleVwiLCBcIltSRURBQ1RFRF1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"strings/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcz8wYWFjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/strings/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicodeNormalizationForm: () => (/* binding */ UnicodeNormalizationForm),\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   Utf8ErrorReason: () => (/* binding */ Utf8ErrorReason),\n/* harmony export */   _toEscapedUtf8String: () => (/* binding */ _toEscapedUtf8String),\n/* harmony export */   _toUtf8String: () => (/* binding */ _toUtf8String),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS91dGY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDbUM7QUFDRDtBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0Esb0VBQW9FLFNBQVMsRUFBRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL3V0ZjguanM/NTU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgdmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcbihmdW5jdGlvbiAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtKSB7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl0gPSBcIk5GRFwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG59KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG47XG5leHBvcnQgdmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyA9IGFycmF5aWZ5KGJ5dGVzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkocmVzdWx0KTtcbn1cbjtcbmZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAyNTYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogcmV0dXJuIFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAzMiAmJiBjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9KS5qb2luKFwiXCIpICsgJ1wiJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"transactions/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanM/ZTU5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/transactions/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionTypes: () => (/* binding */ TransactionTypes),\n/* harmony export */   accessListify: () => (/* binding */ accessListify),\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/../../node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/../../node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/../../node_modules/@ethersproject/signing-key/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/transactions/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nvar TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__.Zero;\n    }\n    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nfunction computeAddress(key) {\n    const publicKey = (0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.computePublicKey)(key);\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress((0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.recoverPublicKey)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataLength)(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\"0x02\", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\"0x01\", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.checkProperties)(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(v));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.r)));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.s)));\n    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[1], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[2], 32);\n    try {\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) { }\n}\nfunction _parseEip1559(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[7], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[8], 32);\n    if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.r), s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) { }\n        tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUN1QztBQUNDO0FBQ2tHO0FBQ3ZHO0FBQ0s7QUFDTztBQUNsQjtBQUNzQztBQUNqQztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQUk7QUFDbkI7QUFDQSxXQUFXLCtEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sd0JBQXdCO0FBQzlCLE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sY0FBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0JBQXNCLDRFQUFnQjtBQUN0QyxXQUFXLGtFQUFVLENBQUMsa0VBQVksQ0FBQyxtRUFBUyxDQUFDLGtFQUFZO0FBQ3pEO0FBQ087QUFDUCwwQkFBMEIsNEVBQWdCLENBQUMsOERBQVE7QUFDbkQ7QUFDQTtBQUNBLG1CQUFtQixnRUFBVSxDQUFDLCtEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFVO0FBQzNCO0FBQ0EsZ0JBQWdCLG1FQUFhO0FBQzdCLDBGQUEwRixLQUFLLEdBQUcsTUFBTTtBQUN4RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILE1BQU07QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHlCQUF5QiwrREFBUztBQUNsQyw2QkFBNkIsK0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0VBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBYztBQUNsQztBQUNBLG9CQUFvQixnRUFBVTtBQUM5QixvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQSxXQUFXLCtEQUFTLFVBQVUsc0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0VBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBYztBQUNsQztBQUNBLG9CQUFvQixnRUFBVTtBQUM5QixvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQSxXQUFXLCtEQUFTLFVBQVUsc0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBUSxDQUFDLDZEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBTztBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFXO0FBQ3RDLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBTyxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBYztBQUM5Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2REFBTztBQUNwQixhQUFhLGdFQUFVLENBQUMsOERBQVE7QUFDaEMsYUFBYSxnRUFBVSxDQUFDLDhEQUFRO0FBQ2hDLFdBQVcsc0RBQVU7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCLEdBQUcseURBQU07QUFDeEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFVO0FBQ3JCLFdBQVcsZ0VBQVU7QUFDckI7QUFDQSx1QkFBdUIsbUVBQVM7QUFDaEMsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBLGdHQUFnRyw2REFBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBLGdHQUFnRyw2REFBTztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBVTtBQUNyQixXQUFXLGdFQUFVO0FBQ3JCLFFBQVEsK0RBQVMsd0JBQXdCLCtEQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFTLENBQUMsc0RBQVU7QUFDM0M7QUFDQSwrQ0FBK0MsR0FBRyw2REFBTyxXQUFXLDZEQUFPLHNDQUFzQztBQUNqSDtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsOERBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVyxHQUFHLHlEQUFNO0FBQ2xGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnZW50aXMvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzPzEwNWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlc0xpa2UsIHNwbGl0U2lnbmF0dXJlLCBzdHJpcFplcm9zLCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSTFAgZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgY29tcHV0ZVB1YmxpY0tleSwgcmVjb3ZlclB1YmxpY0tleSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHZhciBUcmFuc2FjdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblR5cGVzKSB7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wibGVnYWN5XCJdID0gMF0gPSBcImxlZ2FjeVwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDE1NTlcIl0gPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkoVHJhbnNhY3Rpb25UeXBlcyB8fCAoVHJhbnNhY3Rpb25UeXBlcyA9IHt9KSk7XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBaZXJvO1xuICAgIH1cbiAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9uIEZpZWxkc1xuY29uc3QgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcbiAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcbl07XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB0eXBlOiB0cnVlLCB2YWx1ZTogdHJ1ZVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5KGtleSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihoZXhEYXRhU2xpY2UocHVibGljS2V5LCAxKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MocmVjb3ZlclB1YmxpY0tleShhcnJheWlmeShkaWdlc3QpLCBzaWduYXR1cmUpKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmlwWmVyb3MoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIG5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgbmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKHN0b3JhZ2VLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIiwgYGFjY2Vzc0xpc3RbJHthZGRyfToke2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFjY2VzcyBsaXN0IGV4cGVjdGVkIHRvIGJlIFsgYWRkcmVzcywgc3RvcmFnZUtleXNbXSBdXCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgZ2FzUHJpY2UsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZVxuICAgIC8vIEVJUC0xNTU5IGZlZXM7IG90aGVyd2lzZSB0aGV5IG1heSBub3QgdW5kZXJzdGFuZCB3aGF0IHRoZXlcbiAgICAvLyB0aGluayB0aGV5IGFyZSBzZXR0aW5nIGluIHRlcm1zIG9mIGZlZS5cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBnYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuICAgICAgICBpZiAoIWdhc1ByaWNlLmVxKG1heEZlZVBlckdhcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNtYXRjaCBFSVAtMTU1OSBnYXNQcmljZSAhPSBtYXhGZWVQZXJHYXNcIiwgXCJ0eFwiLCB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsIG1heEZlZVBlckdhc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAyXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcucmVjb3ZlcnlQYXJhbSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQoW1wiMHgwMVwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgY29uc3QgcmF3ID0gW107XG4gICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChmaWVsZEluZm8ubnVtZXJpYykge1xuICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KGhleGxpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcbiAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG4gICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwWmVyb3ModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh2YWx1ZSkpO1xuICAgIH0pO1xuICAgIGxldCBjaGFpbklkID0gMDtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWduYXR1cmUgJiYgIWlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcbiAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucHVzaChoZXhsaWZ5KGNoYWluSWQpKTsgLy8gQFRPRE86IGhleFZhbHVlP1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgLy8gVGhlIHNwbGl0U2lnbmF0dXJlIHdpbGwgZW5zdXJlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSByZWNvdmVyeVBhcmFtIGluIHRoZVxuICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG4gICAgbGV0IHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcbiAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmF3LnB1c2goaGV4bGlmeSh2KSk7XG4gICAgcmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucikpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5zKSkpO1xuICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT0gbnVsbCB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAwKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnR5cGVkIHRyYW5zYWN0aW9ucyBkbyBub3Qgc3VwcG9ydCBhY2Nlc3NMaXN0OyBpbmNsdWRlIHR5cGU6IDFcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9ucyAoRUlQLTI3MTgpXG4gICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbi50eXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uLnR5cGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLCBzZXJpYWxpemUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWNpZCA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0pLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR4LnYgPSByZWNpZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIHR4LnIgPSBoZXhaZXJvUGFkKGZpZWxkc1sxXSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKGZpZWxkc1syXSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihzZXJpYWxpemUodHgpKTtcbiAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiB0eC5yLCBzOiB0eC5zLCByZWNvdmVyeVBhcmFtOiB0eC52IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls2XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzhdKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA4ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwicGF5bG9hZFwiLCBoZXhsaWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbls3XSlcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls1XSxcbiAgICAgICAgY2hhaW5JZDogMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHR4LnYgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBXaGF0IG1ha2VzIHNuZXNlIHRvIGRvPyBUaGUgdiBpcyB0b28gYmlnXG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQodHJhbnNhY3Rpb25bN10sIDMyKTtcbiAgICB0eC5zID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls4XSwgMzIpO1xuICAgIGlmIChCaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBCaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuICAgICAgICB0eC52ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNvdmVyeVBhcmFtID0gdHgudiAtIDI3O1xuICAgICAgICBjb25zdCByYXcgPSB0cmFuc2FjdGlvbi5zbGljZSgwLCA2KTtcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT09IDApIHtcbiAgICAgICAgICAgIHJhdy5wdXNoKGhleGxpZnkodHguY2hhaW5JZCkpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoUkxQLmVuY29kZShyYXcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogaGV4bGlmeSh0eC5yKSwgczogaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdHgudHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGFycmF5aWZ5KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHBheWxvYWRbMF0gPiAweDdmKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UocGF5bG9hZCk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9uIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDI5MzAocGF5bG9hZCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHtwYXlsb2FkWzBdfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJwYXJzZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/transactions/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/web/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"web/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpcy8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vX3ZlcnNpb24uanM/YTlkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwid2ViLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/web/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = (opts.mode);\n            }\n            if (opts.cache) {\n                request.cache = (opts.cache);\n            }\n            if (opts.credentials) {\n                request.credentials = (opts.credentials);\n            }\n            if (opts.redirect) {\n                request.redirect = (opts.redirect);\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(new Uint8Array(body)),\n        };\n    });\n}\n//# sourceMappingURL=geturl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL2dldHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ2dEO0FBQ3pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyx3Q0FBd0M7QUFDeEMsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFRO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9nZXR1cmwuanM/NDc4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG4gICAgICAgICAgICBoZWFkZXJzOiAob3B0aW9ucy5oZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgICAgIGJvZHk6IChvcHRpb25zLmJvZHkgfHwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcEZldGNoU2V0dXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubW9kZSA9IFwiY29yc1wiOyAvLyBuby1jb3JzLCBjb3JzLCAqc2FtZS1vcmlnaW5cbiAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSBcIm5vLWNhY2hlXCI7IC8vICpkZWZhdWx0LCBuby1jYWNoZSwgcmVsb2FkLCBmb3JjZS1jYWNoZSwgb25seS1pZi1jYWNoZWRcbiAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBcInNhbWUtb3JpZ2luXCI7IC8vIGluY2x1ZGUsICpzYW1lLW9yaWdpbiwgb21pdFxuICAgICAgICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IFwiZm9sbG93XCI7IC8vIG1hbnVhbCwgKmZvbGxvdywgZXJyb3JcbiAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBcImNsaWVudFwiOyAvLyBuby1yZWZlcnJlciwgKmNsaWVudFxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmV0Y2hPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSAob3B0cy5tb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jYWNoZSA9IChvcHRzLmNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IChvcHRzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IChvcHRzLnJlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlZmVycmVyKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IG9wdHMucmVmZXJyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChocmVmLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKChyZXNwb25zZS5oZWFkZXJzKS5rZXlzKSgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGJvZHk6IGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJvZHkpKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/web/lib.esm/geturl.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@ethersproject/web/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@ethersproject/web/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _fetchData: () => (/* binding */ _fetchData),\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson),\n/* harmony export */   poll: () => (/* binding */ poll)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../../node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/@ethersproject/web/lib.esm/_version.js\");\n/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geturl */ \"(ssr)/../../node_modules/@ethersproject/web/lib.esm/geturl.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = ((typeof (connection) === \"object\") ? !!(connection.errorPassThrough) : false);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.encode)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\") },\n                body: (dataMatch[2] ? (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.decode)(dataMatch[3]) : unpercent(dataMatch[3]))\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield (0,_geturl__WEBPACK_IMPORTED_MODULE_6__.getUrl)(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value));\n            }\n            catch (error) {\n                logger.throwError(\"invalid JSON\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUN1RjtBQUMzQjtBQUNKO0FBQ1c7QUFDcEI7QUFDVjtBQUNyQyxtQkFBbUIseURBQU0sQ0FBQyw2Q0FBTztBQUNDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBVztBQUNuQixtRUFBbUU7QUFDbkU7QUFDQSx1QkFBdUIsb0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBVztBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YseURBQU0sNEJBQTRCLDBFQUEwRTtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBWSxDQUFDLG1FQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzRUFBVztBQUM5QztBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRSxzQ0FBc0MsNkRBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5REFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5REFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQU07QUFDM0M7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlEQUFNO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseURBQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHlEQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseURBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0VBQVk7QUFDaEQ7QUFDQTtBQUNBLGtEQUFrRCx5REFBTTtBQUN4RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQVc7QUFDMUI7QUFDQSxnRUFBZ0UsaUJBQWlCLElBQUksc0VBQVc7QUFDaEc7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNFQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0VBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGlzLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9pbmRleC5qcz80ZWFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWNvZGUgYXMgYmFzZTY0RGVjb2RlLCBlbmNvZGUgYXMgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgZ2V0VXJsIH0gZnJvbSBcIi4vZ2V0dXJsXCI7XG5mdW5jdGlvbiBzdGFsbGVyKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYm9keWlmeSh2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlc0xpa2UodmFsdWUpKSB7XG4gICAgICAgIGlmICh0eXBlICYmICh0eXBlLnNwbGl0KFwiL1wiKVswXSA9PT0gXCJ0ZXh0XCIgfHwgdHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdW5wZXJjZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTYpKTtcbiAgICB9KSk7XG59XG4vLyBUaGlzIEFQSSBpcyBzdGlsbCBhIHdvcmsgaW4gcHJvZ3Jlc3M7IHRoZSBmdXR1cmUgY2hhbmdlcyB3aWxsIGxpa2VseSBiZTpcbi8vIC0gQ29ubmVjdGlvbkluZm8gPT4gRmV0Y2hEYXRhUmVxdWVzdDxUID0gYW55PlxuLy8gLSBGZXRjaERhdGFSZXF1ZXN0LmJvZHk/ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IHsgY29udGVudFR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSB9XG4vLyAgIC0gSWYgc3RyaW5nID0+IHRleHQvcGxhaW4sIFVpbnQ4QXJyYXkgPT4gYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIChpZiBjb250ZW50LXR5cGUgdW5zcGVjaWZpZWQpXG4vLyAtIEZldGNoRGF0YVJlcXVlc3QucHJvY2Vzc0Z1bmMgPSAoYm9keTogVWludDhBcnJheSwgcmVzcG9uc2U6IEZldGNoRGF0YVJlc3BvbnNlKSA9PiBUXG4vLyBGb3IgdGhpcyByZWFzb24sIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGludGVybmFsIHVudGlsIHRoZSBBUEkgaXMgZmluYWxpemVkXG5leHBvcnQgZnVuY3Rpb24gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzRnVuYykge1xuICAgIC8vIEhvdyBtYW55IHRpbWVzIHRvIHJldHJ5IGluIHRoZSBldmVudCBvZiBhIHRocm90dGxlXG4gICAgY29uc3QgYXR0ZW1wdExpbWl0ID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ICE9IG51bGwpID8gY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0IDogMTI7XG4gICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KChhdHRlbXB0TGltaXQgPiAwICYmIChhdHRlbXB0TGltaXQgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIGxpbWl0XCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0XCIsIGF0dGVtcHRMaW1pdCk7XG4gICAgY29uc3QgdGhyb3R0bGVDYWxsYmFjayA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyBjb25uZWN0aW9uLnRocm90dGxlQ2FsbGJhY2sgOiBudWxsKTtcbiAgICBjb25zdCB0aHJvdHRsZVNsb3RJbnRlcnZhbCA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwpID09PSBcIm51bWJlclwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwgOiAxMDApO1xuICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodGhyb3R0bGVTbG90SW50ZXJ2YWwgPiAwICYmICh0aHJvdHRsZVNsb3RJbnRlcnZhbCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgc2xvdCBpbnRlcnZhbFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWxcIiwgdGhyb3R0bGVTbG90SW50ZXJ2YWwpO1xuICAgIGNvbnN0IGVycm9yUGFzc1Rocm91Z2ggPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gISEoY29ubmVjdGlvbi5lcnJvclBhc3NUaHJvdWdoKSA6IGZhbHNlKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgbGV0IHVybCA9IG51bGw7XG4gICAgLy8gQFRPRE86IEFsbG93IENvbm5lY3Rpb25JbmZvIHRvIG92ZXJyaWRlIHNvbWUgb2YgdGhlc2UgdmFsdWVzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIH07XG4gICAgbGV0IGFsbG93MzA0ID0gZmFsc2U7XG4gICAgbGV0IHRpbWVvdXQgPSAyICogNjAgKiAxMDAwO1xuICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVybCA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCB8fCBjb25uZWN0aW9uLnVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBVUkxcIiwgXCJjb25uZWN0aW9uLnVybFwiLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBjb25uZWN0aW9uLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbi50aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiBjb25uZWN0aW9uLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gY29ubmVjdGlvbi50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0geyBrZXk6IGtleSwgdmFsdWU6IFN0cmluZyhjb25uZWN0aW9uLmhlYWRlcnNba2V5XSkgfTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3czMDQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmFsbG93R3ppcCA9ICEhY29ubmVjdGlvbi5hbGxvd0d6aXA7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnVzZXIgIT0gbnVsbCAmJiBjb25uZWN0aW9uLnBhc3N3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsIDYpICE9PSBcImh0dHBzOlwiICYmIGNvbm5lY3Rpb24uYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInVybFwiLCB1cmw6IHVybCwgdXNlcjogY29ubmVjdGlvbi51c2VyLCBwYXNzd29yZDogXCJbUkVEQUNURURdXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5OiBcIkF1dGhvcml6YXRpb25cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArIGJhc2U2NEVuY29kZSh0b1V0ZjhCeXRlcyhhdXRob3JpemF0aW9uKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc2tpcEZldGNoU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5za2lwRmV0Y2hTZXR1cCA9ICEhY29ubmVjdGlvbi5za2lwRmV0Y2hTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5mZXRjaE9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5mZXRjaE9wdGlvbnMgPSBzaGFsbG93Q29weShjb25uZWN0aW9uLmZldGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuICAgIGNvbnN0IGRhdGFNYXRjaCA9ICgodXJsKSA/IHVybC5tYXRjaChyZURhdGEpIDogbnVsbCk7XG4gICAgaWYgKGRhdGFNYXRjaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiY29udGVudC10eXBlXCI6IChkYXRhTWF0Y2hbMV0gfHwgXCJ0ZXh0L3BsYWluXCIpIH0sXG4gICAgICAgICAgICAgICAgYm9keTogKGRhdGFNYXRjaFsyXSA/IGJhc2U2NERlY29kZShkYXRhTWF0Y2hbM10pIDogdW5wZXJjZW50KGRhdGFNYXRjaFszXSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXNwb25zZS5ib2R5LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGRhdGFNYXRjaFsxXSwgZGF0YU1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIjtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHsga2V5OiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0geyBrZXk6IFwiQ29udGVudC1MZW5ndGhcIiwgdmFsdWU6IFN0cmluZyhib2R5Lmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmbGF0SGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2tleV07XG4gICAgICAgIGZsYXRIZWFkZXJzW2hlYWRlci5rZXldID0gaGVhZGVyLnZhbHVlO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IGZsYXRIZWFkZXJzO1xuICAgIGNvbnN0IHJ1bm5pbmdUaW1lb3V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBwcm9taXNlLCBjYW5jZWwgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHJ1bm5pbmdGZXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdDsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIGdldFVybCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRhaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzOi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2stb2ZmIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWxsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGxlcihzdGFsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93MzA0ICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWVycm9yUGFzc1Rocm91Z2ggJiYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keSwgKChyZXNwb25zZS5oZWFkZXJzKSA/IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvY2Vzc0Z1bmMoYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHByb2Nlc3NGdW5jIHRvIHRyaWdnZXIgYSB0aHJvdHRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlUmV0cnkgJiYgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cnlBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm90dGxlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSB5aWVsZCB0aHJvdHRsZUNhbGxiYWNrKGF0dGVtcHQsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnlBZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGxlcih0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGEgcHJvY2Vzc0Z1bmMsIGl0IGVpdGhlciByZXR1cm5lZCBhIFQgb3IgdGhyZXcgYWJvdmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYm9keVwiIGlzIG5vdyBhIFVpbnQ4QXJyYXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbcnVubmluZ1RpbWVvdXQucHJvbWlzZSwgcnVubmluZ0ZldGNoXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hKc29uKGNvbm5lY3Rpb24sIGpzb24sIHByb2Nlc3NGdW5jKSB7XG4gICAgbGV0IHByb2Nlc3NKc29uRnVuYyA9ICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UodG9VdGY4U3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImludmFsaWQgSlNPTlwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXN1bHQsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gSWYgd2UgaGF2ZSBqc29uIHRvIHNlbmQsIHdlIG11c3RcbiAgICAvLyAtIGFkZCBjb250ZW50LXR5cGUgb2YgYXBwbGljYXRpb24vanNvbiAodW5sZXNzIGFscmVhZHkgb3ZlcnJpZGRlbilcbiAgICAvLyAtIGNvbnZlcnQgdGhlIGpzb24gdG8gYnl0ZXNcbiAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgaWYgKGpzb24gIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gdG9VdGY4Qnl0ZXMoanNvbik7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgY29udGVudC10eXBlIHNldCBmb3IgSlNPTlxuICAgICAgICBjb25zdCB1cGRhdGVkID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpID8gKHsgdXJsOiBjb25uZWN0aW9uIH0pIDogc2hhbGxvd0NvcHkoY29ubmVjdGlvbik7XG4gICAgICAgIGlmICh1cGRhdGVkLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gKE9iamVjdC5rZXlzKHVwZGF0ZWQuaGVhZGVycykuZmlsdGVyKChrKSA9PiAoay50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiKSkubGVuZ3RoKSAhPT0gMDtcbiAgICAgICAgICAgIGlmICghaGFzQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnMgPSBzaGFsbG93Q29weSh1cGRhdGVkLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0geyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24gPSB1cGRhdGVkO1xuICAgIH1cbiAgICByZXR1cm4gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzSnNvbkZ1bmMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvbGwoZnVuYywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBzaGFsbG93Q29weShvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5mbG9vciA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuZmxvb3IgPSAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jZWlsaW5nID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5jZWlsaW5nID0gMTAwMDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmludGVydmFsID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5pbnRlcnZhbCA9IDI1MDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGNhbmNlbCB3YXMgc3VjY2Vzc2Z1bC4gVW5zdWNjZXNzZnVsIGNhbmNlbCBtZWFucyB3ZSdyZSBhbHJlYWR5IGRvbmUuXG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5TGltaXQgPSBvcHRpb25zLnJldHJ5TGltaXQ7XG4gICAgICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSByZXN1bHQsIG9yIGFyZSBhbGxvd2VkIG51bGwgdGhlbiB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZVBvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlUG9sbC5vbmNlKFwicG9sbFwiLCBjaGVjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZUJsb2NrLm9uY2UoXCJibG9ja1wiLCBjaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZXhwb25lbnRpYWwgYmFjay1vZmYgKHVwIHRvIDEwcykgb3VyIG5leHQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gcmV0cnlMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJldHJ5IGxpbWl0IHJlYWNoZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gb3B0aW9ucy5pbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCBvcHRpb25zLmZsb29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5mbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IG9wdGlvbnMuY2VpbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuY2VpbGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjaGVjaygpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@ethersproject/web/lib.esm/index.js\n");

/***/ })

};
;